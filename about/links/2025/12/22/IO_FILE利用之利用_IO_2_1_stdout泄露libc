<!DOCTYPE html><html lang="zh-CN" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>IO_FILE利用之利用_IO_2_1_stdout泄露libc | Langx</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.woff2"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><meta name="page-config" content="{&quot;code_fold&quot;:null}"><script class="pjax-js">var config = {"root":"/","code_fold":15,"search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}};
var page_config = {
  code_fold: null
};
function updatePageConfig() {
  var newPageConfig = document.querySelector('meta[name="page-config"]');
  if (newPageConfig) {
    page_config = JSON.parse(newPageConfig.content);
  }
}
document.addEventListener('pjax:complete', function() { updatePageConfig(); });
updatePageConfig();</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('/img/%E5%B2%81.jpg');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: '确认'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer src="https://vercount.one/js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.vercount','meta[name=page-config]'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => {
 const script = document.createElement('script');
 script.src = 'https://vercount.one/js';
 document.head.appendChild(script);
});reset()})</script><script class="pjax-js">reset= () => {MathJax.Hub.Queue(["Typeset", MathJax.Hub]);document.querySelector('.lg-container')?.remove()
const postBg = document.querySelector('#post-bg');
if (postBg) lightGallery(postBg, {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.vercount','meta[name=page-config]'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => {
 const script = document.createElement('script');
 script.src = 'https://vercount.one/js';
 document.head.appendChild(script);
});reset()})</script><meta name="generator" content="Hexo 8.1.1"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">主页</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">归档页</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">关于我</span></a></li><li class="navItem"><a class="navBlock" href="/%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F/"><span class="navItemTitle">联系方式</span></a></li><li class="navItem"><a class="navBlock" href="/links/"><span class="navItemTitle">友链</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>IO_FILE利用之利用_IO_2_1_stdout泄露libc</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2025-12-22T12:56:53.875Z" id="date"> 2025-12-22</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2025-12-27T06:46:17.899Z" id="updated"> 2025-12-27</time></div></span><br><span id="vercount_container_page_pv">页面浏览: <span class="control" id="vercount_value_page_pv">加载中...</span></span></div></div><hr><div id="post-content"><h1 id="IO-FILE利用之利用-IO-2-1-stdout泄露libc"><a href="#IO-FILE利用之利用-IO-2-1-stdout泄露libc" class="headerlink" title="IO_FILE利用之利用_IO_2_1_stdout泄露libc"></a><strong>IO_FILE利用之利用_IO_2_1_stdout泄露libc</strong></h1><p><em><strong>FILE结构</strong></em><br>FILE在linux系统的标准IO库使用来描述文件结构，称之为文件流。这里提及的”流“其实是一种抽象的概念，无论是硬件还是软件其实都没有”流“一说，只是人们为了便于描述数据的流向而创造的名称。比如说当我们要输出磁盘中记录的数据，那么在计算机中首先会将磁盘中的数据加载进内存，那么磁盘–&gt;内存这种流向就被抽象叫做”流“</p>
<p>FILE结构在程序执行fopen函数时会自动进行创建，并分配在堆中。我们常定义一个指向FILE结构的指针来接收这个返回值</p>
<p>FILE结构定义在libio.h:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> &#123;</span><br>  <span class="hljs-type">int</span> _flags;       <span class="hljs-comment">/* High-order word is _IO_MAGIC; rest is flags. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_file_flags _flags</span><br><br>  <span class="hljs-comment">/* The following pointers correspond to the C++ streambuf protocol. */</span><br>  <span class="hljs-comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span><br>  <span class="hljs-type">char</span>* _IO_read_ptr;   <span class="hljs-comment">/* Current read pointer */</span><br>  <span class="hljs-type">char</span>* _IO_read_end;   <span class="hljs-comment">/* End of get area. */</span><br>  <span class="hljs-type">char</span>* _IO_read_base;  <span class="hljs-comment">/* Start of putback+get area. */</span><br>  <span class="hljs-type">char</span>* _IO_write_base; <span class="hljs-comment">/* Start of put area. */</span><br>  <span class="hljs-type">char</span>* _IO_write_ptr;  <span class="hljs-comment">/* Current put pointer. */</span><br>  <span class="hljs-type">char</span>* _IO_write_end;  <span class="hljs-comment">/* End of put area. */</span><br>  <span class="hljs-type">char</span>* _IO_buf_base;   <span class="hljs-comment">/* Start of reserve area. */</span><br>  <span class="hljs-type">char</span>* _IO_buf_end;    <span class="hljs-comment">/* End of reserve area. */</span><br>  <span class="hljs-comment">/* The following fields are used to support backing up and undo. */</span><br>  <span class="hljs-type">char</span> *_IO_save_base; <span class="hljs-comment">/* Pointer to start of non-current get area. */</span><br>  <span class="hljs-type">char</span> *_IO_backup_base;  <span class="hljs-comment">/* Pointer to first valid character of backup area */</span><br>  <span class="hljs-type">char</span> *_IO_save_end; <span class="hljs-comment">/* Pointer to end of non-current get area. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_marker</span> *_<span class="hljs-title">markers</span>;</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *_<span class="hljs-title">chain</span>;</span><br><br>  <span class="hljs-type">int</span> _fileno;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>  <span class="hljs-type">int</span> _blksize;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-type">int</span> _flags2;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  _IO_off_t _old_offset; <span class="hljs-comment">/* This used to be _offset but it&#x27;s too small.  */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __HAVE_COLUMN <span class="hljs-comment">/* temporary */</span></span><br>  <span class="hljs-comment">/* 1+column number of pbase(); 0 is unknown. */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> _cur_column;<br>  <span class="hljs-type">signed</span> <span class="hljs-type">char</span> _vtable_offset;<br>  <span class="hljs-type">char</span> _shortbuf[<span class="hljs-number">1</span>];<br><br>  <span class="hljs-comment">/*  char* _save_gptr;  char* _save_egptr; */</span><br><br>  _IO_lock_t *_lock;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE_complete</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> _<span class="hljs-title">file</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span><br>  _IO_off64_t _offset;<br><span class="hljs-meta"># <span class="hljs-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br>  <span class="hljs-comment">/* Wide character stream stuff.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_codecvt</span> *_<span class="hljs-title">codecvt</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_wide_data</span> *_<span class="hljs-title">wide_data</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *_<span class="hljs-title">freeres_list</span>;</span><br>  <span class="hljs-type">void</span> *_freeres_buf;<br><span class="hljs-meta"># <span class="hljs-keyword">else</span></span><br>  <span class="hljs-type">void</span> *__pad1;<br>  <span class="hljs-type">void</span> *__pad2;<br>  <span class="hljs-type">void</span> *__pad3;<br>  <span class="hljs-type">void</span> *__pad4;<br><br>  <span class="hljs-type">size_t</span> __pad5;<br>  <span class="hljs-type">int</span> _mode;<br>  <span class="hljs-comment">/* Make sure we don&#x27;t get into trouble again.  */</span><br>  <span class="hljs-type">char</span> _unused2[<span class="hljs-number">15</span> * <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">int</span>) - <span class="hljs-number">4</span> * <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">void</span> *) - <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">size_t</span>)];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>一个进程中的FILE结构会通过_chain域彼此连接形成一个链表，链表的头部用全局变量 _IO_list_all表示，通过这个值我们能遍历所有的FILE结构。</p>
<p>如图：</p>
<p class='item-img' data-src='https://github.com/langx1ng/-/blob/main/6914c415595bd19d35a7c1e838b23d74.png?raw=true'><img src="https://github.com/langx1ng/-/blob/main/6914c415595bd19d35a7c1e838b23d74.png?raw=true"></p>
<p>在标准I&#x2F;O库中，每个程序启动时stdin、stdout、stderr这三个文件流会自动打开。因此在初始状态下，_IO_list_all指向了一个由这些文件流构成的链表，但是这三个文件流是位于libc.so的数据段上，而我们使用fopen创建的文件流是分配在堆内存上的</p>
<p><em><strong>_IO_FILE_plus结构</strong></em></p>
<p>在FILE结构外还包裹了另一种结构_IO_FILE_plus,其中包含了一个重要的指针vtable(虚表)指向了一系列函数指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE_plus</span></span><br><span class="hljs-class">&#123;</span><br>  FILE file;<br>  <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_jump_t</span> *<span class="hljs-title">vtable</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>虚函数表是一个存储在内存中的表格，其中包含了类中所有虚函数的指针，每个类都有自己的虚函数表。当调用虚函数时，编译器通过虚函数表来确定应该调用哪个函数的实现。</p>
</blockquote>
<p>这里可以看见vtable是<code>IO_jump_t</code> 类型的指针，<code>IO_jump_t</code>中保存了一些函数指针，在后面我们会看到在一系列标准 IO 函数中会调用这些函数指针。也就是说，如果使用_IO_FILE_plus去定义一个结构体指针的话，我们既可以使用IO_FILE中的结构体成员变量，也能使用IO_jump_t中的函数指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_jump_t</span></span><br><span class="hljs-class">&#123;</span><br>    JUMP_FIELD(<span class="hljs-type">size_t</span>, __dummy);<br>    JUMP_FIELD(<span class="hljs-type">size_t</span>, __dummy2);<br>    JUMP_FIELD(_IO_finish_t, __finish);<br>    JUMP_FIELD(_IO_overflow_t, __overflow);<br>    JUMP_FIELD(_IO_underflow_t, __underflow);<br>    JUMP_FIELD(_IO_underflow_t, __uflow);<br>    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);<br>    <span class="hljs-comment">/* showmany */</span><br>    JUMP_FIELD(_IO_xsputn_t, __xsputn);<br>    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);<br>    JUMP_FIELD(_IO_seekoff_t, __seekoff);<br>    JUMP_FIELD(_IO_seekpos_t, __seekpos);<br>    JUMP_FIELD(_IO_setbuf_t, __setbuf);<br>    JUMP_FIELD(_IO_sync_t, __sync);<br>    JUMP_FIELD(_IO_doallocate_t, __doallocate);<br>    JUMP_FIELD(_IO_read_t, __read);<br>    JUMP_FIELD(_IO_write_t, __write);<br>    JUMP_FIELD(_IO_seek_t, __seek);<br>    JUMP_FIELD(_IO_close_t, __close);<br>    JUMP_FIELD(_IO_stat_t, __stat);<br>    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);<br>    JUMP_FIELD(_IO_imbue_t, __imbue);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><em><strong>_flags规则</strong></em></p>
<p>_flag是IO_FILE结构体中的第一个成员变量，这个成员变量在利用 _IO_2_1_stdout泄露libc的时候起了很重要的作用。</p>
<p>_flag规则： _flag的高两位字节是由libc固定的，不同的libc可能存在差异，但是基本上都是<code>0xfbad0000</code></p>
<p>高两位字节的作用是作为一个标识，标志这是一个什么文件。而低两位的位数决定了程序的执行状态，低两位规则如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_MAGIC       0xFBAD0000  <span class="hljs-comment">// 文件流结构体的魔数</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _OLD_STDIO_MAGIC 0xFABC0000 <span class="hljs-comment">// 旧版 stdio 的魔数（兼容用）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_MAGIC_MASK  0xFFFF0000  <span class="hljs-comment">// 魔数掩码（提取高 16 位）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_USER_BUF   1   <span class="hljs-comment">// 用户自定义缓冲区（关闭时不释放）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_UNBUFFERED 2   <span class="hljs-comment">// 无缓冲模式（直接操作文件描述符）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_NO_READS   4   <span class="hljs-comment">// 禁止读操作（只写模式）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_NO_WRITES  8   <span class="hljs-comment">// 禁止写操作（只读模式）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_EOF_SEEN   0x10  <span class="hljs-comment">// 已检测到文件结束符（EOF）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_ERR_SEEN   0x20  <span class="hljs-comment">// 发生 I/O 错误（如磁盘故障）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_BAD_SEEN   0x4000 <span class="hljs-comment">// 流处于不可恢复的错误状态</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_DELETE_DONT_CLOSE 0x40  <span class="hljs-comment">// 关闭时不调用 close(_fileno)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_LINKED            0x80  <span class="hljs-comment">// 与其他流链接（共享缓冲区）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_IN_BACKUP         0x100 <span class="hljs-comment">// 正在备份数据（如内存映射回写）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_LINE_BUF          0x200 <span class="hljs-comment">// 行缓冲模式（遇到 &#x27;\n&#x27; 刷新）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_TIED_PUT_GET      0x400 <span class="hljs-comment">// 读写指针逻辑绑定（如 fgetpos/fsetpos）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_CURRENTLY_PUTTING 0x800 <span class="hljs-comment">// 当前处于写操作中</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_IS_APPENDING      0x1000 <span class="hljs-comment">// 追加模式（文件打开时指针在末尾）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_IS_FILEBUF        0x2000 <span class="hljs-comment">// 文件缓冲区（非终端或管道）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_USER_LOCK 0x8000  <span class="hljs-comment">// 用户自定义锁（控制并发访问）</span></span><br></code></pre></td></tr></table></figure>

<p>在执行流程中一般会将_flag和定义常量进行按位与运算，并根据与运算的结构进行判断如何执行。</p>
<p><em><strong>puts()函数执行流程</strong></em></p>
<p><strong>_IO_puts –&gt; _IO_new_file_xsputn</strong></p>
<p>puts()函数在源码中的表现形式为_IO_puts:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br>_IO_puts (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)<br>&#123;<br>  <span class="hljs-type">int</span> result = EOF;              <span class="hljs-comment">// 初始化返回值为 EOF（表示失败）</span><br>  <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span> (str);     <span class="hljs-comment">// 计算字符串长度（不含 &#x27;\0&#x27;）</span><br>  _IO_acquire_lock (<span class="hljs-built_in">stdout</span>);     <span class="hljs-comment">// 获取 stdout 的锁（防止并发写入）</span><br><br>  <span class="hljs-comment">// 检查流的虚表偏移和宽字符模式是否合法</span><br>  <span class="hljs-keyword">if</span> ((_IO_vtable_offset (<span class="hljs-built_in">stdout</span>) != <span class="hljs-number">0</span><br>       || _IO_fwide (<span class="hljs-built_in">stdout</span>, <span class="hljs-number">-1</span>) == <span class="hljs-number">-1</span>)  <span class="hljs-comment">// 确保流处于字节模式（非宽字符）</span><br>      &amp;&amp; _IO_sputn (<span class="hljs-built_in">stdout</span>, str, len) == len  <span class="hljs-comment">// 将字符串写入缓冲区</span><br>      &amp;&amp; _IO_putc_unlocked (<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-built_in">stdout</span>) != EOF)  <span class="hljs-comment">// 写入换行符</span><br>    result = MIN (INT_MAX, len + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 成功时返回写入字符数（含 &#x27;\n&#x27;）</span><br><br>  _IO_release_lock (<span class="hljs-built_in">stdout</span>);       <span class="hljs-comment">// 释放锁</span><br>  <span class="hljs-keyword">return</span> result;                   <span class="hljs-comment">// 返回结果</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里可以看到_IO_puts在过程当中调用了一个叫做<code>_IO_sputn</code>函数（_IO_fwrite也会调用这个），_IO_sputn其实是一个<code>宏</code>，它的作用就是调用<code>_IO_2_1_stdout_</code>中的<code>vtable</code>所指向的<code>_xsputn</code>，也就是<code>_IO_new_file_xsputn</code>函数</p>
<p><strong>_IO_new_file_xsputn –&gt; _IO_OVERFLOW</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span><br>_IO_new_file_xsputn (FILE *f, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> n)<br>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s = (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *) data;<br>  <span class="hljs-type">size_t</span> to_do = n;<br>  <span class="hljs-type">int</span> must_flush = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">size_t</span> count = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/* This is an optimized implementation.</span><br><span class="hljs-comment">     If the amount to be written straddles a block boundary</span><br><span class="hljs-comment">     (or the filebuf is unbuffered), use sys_write directly. */</span><br><br>  <span class="hljs-comment">/* First figure out how much space is available in the buffer. */</span><br>  <span class="hljs-keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))<br>    &#123;<br>      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;<br>      <span class="hljs-keyword">if</span> (count &gt;= n)<br>	&#123;<br>	  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *p;<br>	  <span class="hljs-keyword">for</span> (p = s + n; p &gt; s; )<br>	    &#123;<br>	      <span class="hljs-keyword">if</span> (*--p == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>		&#123;<br>		  count = p - s + <span class="hljs-number">1</span>;<br>		  must_flush = <span class="hljs-number">1</span>;<br>		  <span class="hljs-keyword">break</span>;<br>		&#125;<br>	    &#125;<br>	&#125;<br>    &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)<br>    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="hljs-comment">/* Space available. */</span><br><br>  <span class="hljs-comment">/* Then fill the buffer. */</span><br>  <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (count &gt; to_do)<br>	count = to_do;<br>      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);<br>      s += count;<br>      to_do -= count;<br>    &#125;<br>  <span class="hljs-keyword">if</span> (to_do + must_flush &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-type">size_t</span> block_size, do_write;<br>      <span class="hljs-comment">/* Next flush the (full) buffer. */</span><br>      <span class="hljs-keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)<br>	<span class="hljs-comment">/* If nothing else has to be written we must not signal the</span><br><span class="hljs-comment">	   caller that everything has been written.  */</span><br>	<span class="hljs-keyword">return</span> to_do == <span class="hljs-number">0</span> ? EOF : n - to_do;<br><br>      <span class="hljs-comment">/* Try to maintain alignment: write a whole number of blocks.  */</span><br>      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;<br>      do_write = to_do - (block_size &gt;= <span class="hljs-number">128</span> ? to_do % block_size : <span class="hljs-number">0</span>);<br><br>      <span class="hljs-keyword">if</span> (do_write)<br>	&#123;<br>	  count = new_do_write (f, s, do_write);<br>	  to_do -= count;<br>	  <span class="hljs-keyword">if</span> (count &lt; do_write)<br>	    <span class="hljs-keyword">return</span> n - to_do;<br>	&#125;<br><br>      <span class="hljs-comment">/* Now write out the remainder.  Normally, this will fit in the</span><br><span class="hljs-comment">	 buffer, but it&#x27;s somewhat messier for line-buffered files,</span><br><span class="hljs-comment">	 so we let _IO_default_xsputn handle the general case. */</span><br>      <span class="hljs-keyword">if</span> (to_do)<br>	to_do -= _IO_default_xsputn (f, s+do_write, to_do);<br>    &#125;<br>  <span class="hljs-keyword">return</span> n - to_do;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>首先进入函数之后判断输出缓冲区还有多少空间，这里是由<code>_IO_write_end - _IO_write_base</code>得来的，这两个是FILE结构体中的两个成员变量，分别是输出结束地址和真实输出地址</p>
<p>关键代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1335</span>    <span class="hljs-keyword">if</span> (__IO_OVERFLOW (f, EOF) == EOF)<br><span class="hljs-number">1336</span>      <span class="hljs-comment">/* If nothing else has to be written we must not signal the </span><br><span class="hljs-comment">1337         caller that everything has been written. */</span><br><span class="hljs-number">1338</span>      <span class="hljs-keyword">return</span> to_do == <span class="hljs-number">0</span> ? EOF : n - to_do;<br></code></pre></td></tr></table></figure>

<p>经过上述最后一步的判断，如果还有剩余则说明输出缓冲区未建立或者空间已满，那么就需要通过<code>_IO_OVERFLOW</code>函数来建立或清空缓冲区，这个函数主要是实现刷新缓冲区或建立缓冲区的功能。在vtable中为<code>__overflow</code></p>
<p><strong>_IO_new_file_overflow –&gt; _IO_do_write</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br>_IO_new_file_overflow (FILE *f, <span class="hljs-type">int</span> ch)<br>&#123;<br>  <span class="hljs-keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="hljs-comment">/* SET ERROR */</span><br>    &#123;<br>      f-&gt;_flags |= _IO_ERR_SEEN;<br>      __set_errno (EBADF);<br>      <span class="hljs-keyword">return</span> EOF;<br>    &#125;<br>  <span class="hljs-comment">/* If currently reading or no buffer allocated. */</span><br>  <span class="hljs-keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="hljs-number">0</span> || f-&gt;_IO_write_base == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-comment">/* Allocate a buffer if needed. */</span><br>      <span class="hljs-keyword">if</span> (f-&gt;_IO_write_base == <span class="hljs-literal">NULL</span>)<br>	&#123;<br>	  _IO_doallocbuf (f);<br>	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);<br>	&#125;<br>      <span class="hljs-comment">/* Otherwise must be currently reading.</span><br><span class="hljs-comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span><br><span class="hljs-comment">	 logically slide the buffer forwards one block (by setting the</span><br><span class="hljs-comment">	 read pointers to all point at the beginning of the block).  This</span><br><span class="hljs-comment">	 makes room for subsequent output.</span><br><span class="hljs-comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span><br><span class="hljs-comment">	 alone, so it can continue to correspond to the external position). */</span><br>      <span class="hljs-keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))<br>	&#123;<br>	  <span class="hljs-type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;<br>	  _IO_free_backup_area (f);<br>	  f-&gt;_IO_read_base -= MIN (nbackup,<br>				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);<br>	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;<br>	&#125;<br><br>      <span class="hljs-keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)<br>	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;<br>      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;<br>      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;<br>      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;<br>      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;<br><br>      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;<br>      <span class="hljs-keyword">if</span> (f-&gt;_mode &lt;= <span class="hljs-number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))<br>	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;<br>    &#125;<br>  <span class="hljs-keyword">if</span> (ch == EOF)<br>    <span class="hljs-keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);<br>  <span class="hljs-keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="hljs-comment">/* Buffer is really full */</span><br>    <span class="hljs-keyword">if</span> (_IO_do_flush (f) == EOF)<br>      <span class="hljs-keyword">return</span> EOF;<br>  *f-&gt;_IO_write_ptr++ = ch;<br>  <span class="hljs-keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)<br>      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="hljs-string">&#x27;\n&#x27;</span>))<br>    <span class="hljs-keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,<br>		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)<br>      <span class="hljs-keyword">return</span> EOF;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>) ch;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上述代码关键在于 <code>_IO_do_write (f, f-&gt;_IO_write_base,f-&gt;_IO_write_ptr - f-&gt;_IO_write_base)</code> ，我们需要成功执行 _ IO _ do_write()函数，这个函数作用是调用write输出输出缓冲区，传入的参数分别为：<code>stdout结构体</code>、<code>_IO_write_base</code>（输出缓冲区起始地址）和<code>size</code>（_IO_write_end - _IO_write_base计算得来）</p>
<p>这时，我们可以事先在stdout的<code>_IO_write_base</code>的位置部署要输出的起始地址，那么再去利用_IO_do_write函数，即可打印部分内存地址，打印出来的内容就包含我们所需要泄露的libc</p>
<p>为了执行_ IO _ do_write()函数，我们得绕过前面的检查</p>
<p>首先：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="hljs-comment">/* SET ERROR */</span><br>   &#123;<br>     f-&gt;_flags |= _IO_ERR_SEEN;<br>     __set_errno (EBADF);<br>     <span class="hljs-keyword">return</span> EOF;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>这里判断_flags的标志位是否包含 _IO_NO_WRITES，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_MAGIC 0xFBAD0000 <span class="hljs-comment">/* 魔数 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_NO_WRITES  8   <span class="hljs-comment">// 禁止写操作（只读模式）</span></span><br></code></pre></td></tr></table></figure>

<p>为了通过这个检查，我们得将此处的运算计算为假，所以我们只需要将_flag设置为<code>0xfbad0000</code>即可</p>
<blockquote>
<p> _flag&#x3D;<strong><code>0xFBAD0000</code></strong>  –&gt;  <code>11111011101011010000000000000000</code>  (第三位为0即可)</p>
<p>_IO_NO_WRITES &#x3D; 8 –&gt; <code>00000000000000000000000000001000</code></p>
</blockquote>
<p>第二个大检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="hljs-number">0</span> || f-&gt;_IO_write_base == <span class="hljs-literal">NULL</span>)&#123;...&#125;<br></code></pre></td></tr></table></figure>

<p>由于<code>_IO_write_base</code>我们会先覆盖地址，所以 <code>f-&gt;_IO_write_base == NULL</code>必定为假，接下来我们令<code>(f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0</code> 为假即可,设置_flags &#x3D; <code>0xfbad0800</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_MAGIC 0xFBAD0000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_CURRENTLY_PUTTING 0x800</span><br>f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING = <span class="hljs-number">1</span><br>_flags = <span class="hljs-number">0xfbad0800</span><br></code></pre></td></tr></table></figure>

<p>第三个检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ch == EOF)<br>  <span class="hljs-keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);<br></code></pre></td></tr></table></figure>

<p>由于前面传进来的参数就是EOF所以不用管</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__IO_OVERFLOW (f, EOF) == EOF)<br></code></pre></td></tr></table></figure>

<p>绕过了这些检查后</p>
<p>我们就成功进入了_IO_do_write() 函数</p>
<p><strong>_IO_new_do_write –&gt; new_do_write</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br>_IO_new_do_write (FILE *fp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data, <span class="hljs-type">size_t</span> to_do)<br>&#123;<br>  <span class="hljs-keyword">return</span> (to_do == <span class="hljs-number">0</span><br>	  || (<span class="hljs-type">size_t</span>) new_do_write (fp, data, to_do) == to_do) ? <span class="hljs-number">0</span> : EOF;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们进入_IO_do_write() 函数之后就会进入 _IO_new_do_write函数，该函数只是调用了new_do_write函数，参数分别为stdout结构体，输出缓冲区起始地址，输出长度</p>
<p>跟进new_do_write函数</p>
<p><strong>new_do_write –&gt; _IO_SYSWRITE</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">size_t</span><br><span class="hljs-title function_">new_do_write</span> <span class="hljs-params">(FILE *fp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data, <span class="hljs-type">size_t</span> to_do)</span><br>&#123;<br>  <span class="hljs-type">size_t</span> count;<br>  <span class="hljs-keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)<br>    <span class="hljs-comment">/* On a system without a proper O_APPEND implementation,</span><br><span class="hljs-comment">       you would need to sys_seek(0, SEEK_END) here, but is</span><br><span class="hljs-comment">       not needed nor desirable for Unix- or Posix-like systems.</span><br><span class="hljs-comment">       Instead, just indicate that offset (before and after) is</span><br><span class="hljs-comment">       unpredictable. */</span><br>    fp-&gt;_offset = _IO_pos_BAD;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)<br>    &#123;<br>      <span class="hljs-type">off64_t</span> new_pos<br>	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">if</span> (new_pos == _IO_pos_BAD)<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      fp-&gt;_offset = new_pos;<br>    &#125;<br>  count = _IO_SYSWRITE (fp, data, to_do);<br>  <span class="hljs-keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)<br>    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="hljs-number">1</span>, data, count) + <span class="hljs-number">1</span>;<br>  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);<br>  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;<br>  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="hljs-number">0</span><br>		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))<br>		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);<br>  <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>关键代码：<code>count = _IO_SYSWRITE (fp, data, to_do);</code>首先明确目标是进入这个函数，该函数会执行系统调用write。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)<br></code></pre></td></tr></table></figure>

<p>接下来就是考虑这两个判断语句了我们进入第一个if语句的话可以执行<code>count = _IO_SYSWRITE (fp, data, to_do);</code>,所以我们就不需要满足<code>else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</code>的条件了（这个条件比较难满足）</p>
<p>所以我们将_flags设置为0xfbad1000即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_MAGIC 0xFBAD0000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_IS_APPENDING 0x1000</span><br>fp-&gt;_flags &amp; _IO_IS_APPENDING = <span class="hljs-number">1</span><br>_flags = <span class="hljs-number">0xfbad1000</span><br></code></pre></td></tr></table></figure>

<p>接下来就可以执行 <code>_IO_SYSWRITE (fp, data, to_do)</code>函数打印出我们一开始设置的要输出的起始地址，从而达到泄露libc的目的了</p>
<p><em><strong>总结：</strong></em></p>
<p>我们得满足以下条件来执行<code>_IO_SYSWRITE (fp, data, to_do)</code>：</p>
<ul>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">_flags &amp; _IO_NO_WRITES = <span class="hljs-number">0</span><br>_flags &amp; _IO_CURRENTLY_PUTTING = <span class="hljs-number">1</span><br>_flags &amp; _IO_IS_APPENDING = <span class="hljs-number">1</span><br>_flags = <span class="hljs-number">0xFBAD1800</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>设置_IO_write_base指向想要泄露的位置，_IO_write_ptr指向泄露结束的地址(不需要一定设置指向结尾，stdout结构中自带地址也足够泄露libc)</p>
</li>
</ul>
<blockquote>
<p>参考blog：<a target="_blank" rel="noopener" href="https://hollk.blog.csdn.net/article/details/113845320">https://hollk.blog.csdn.net/article/details/113845320</a></p>
</blockquote>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/about/links/2025/12/22/CTFshow%20%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%20162-...%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0">← 下一篇 CTFshow 刷题记录 162-...持续更新</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/about/links/2025/12/22/IO%E5%88%A9%E7%94%A8%E4%B9%8B%E4%BC%AA%E9%80%A0vtable%E5%8A%AB%E6%8C%81%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B">IO利用之伪造 Vtable 劫持程序流程 上一篇 →</a></div></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img alt="Logo" style="margin:0;border-radius:0;"></a><h1 id="Dr"><a href="/">Langx</a></h1><div id="description"><p>this world is pretty</p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/langx1ng"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" href="mailto:2867485668@qq.com"><i class="fa fa-envelope" alt="E-Mail"></i></a><a class="social" target="_blank" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=2867485668&amp;site=qq&amp;menu=yes"><i class="fa-brands fa-qq" alt="QQ"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IO-FILE%E5%88%A9%E7%94%A8%E4%B9%8B%E5%88%A9%E7%94%A8-IO-2-1-stdout%E6%B3%84%E9%9C%B2libc"><span class="toc-number">1.</span> <span class="toc-text">IO_FILE利用之利用_IO_2_1_stdout泄露libc</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr><wbr><nobr> 构建时间<script>const buildTime = new Date("2025-12-31T03:45:25.203Z");
document.write(' ' + buildTime.toLocaleString());</script></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>